
# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.


## Σημειώσεις για τις ασκήσεις: 1-10
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** η χρήση της ```if``` (αν τη χρησιμοποιείσετε χάνετε τη μισή άσκηση)
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)

Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
	if n%2 == 1:
		return True
	else:
		return False

```

Τι να κάνετε:
```python
def f(n):
	return n%2 == 1
```


### Άσκηση 1
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι μονός θα απιτρέφει: ```True```
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι ζυγός (άρτιος) θα επιστρέφει ```False```

Λύση:
```python
def f(x):
	return (x%7) % 2 == 1
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν ο αριθμός ανήκει στο διάστημα \[100,200\] (δηλαδή είναι μεγαλύτερος ή ίσος από το 100 και μικρότερος ή ίσος από το 200) η συνάρτηση θα επιστρέφει ```True```.
* Aν o αριθμός ΔΕΝ ανήκει στο διάστημα \[100, 200\] η συνάρτηση θα επιστρέφει ```False```.

Λύση:
```python
# 1st solution
def f(x):
	return x>=100 and x<=200

# 2nd solution
def f(x):
	return 100 <= x <= 200
```



### Άσκηση 3
Υπολογίστε και τυπώστε τις τιμές της συνάρτησης:

f(x)=-8x<sup>2</sup> + 5x - 2

Για x=5, x=6, x=7


```python
def f(x):
	return (-8*(x**2)) + (5*x) -2

print (f(5))
print (f(6))
print (f(7))
```

### Άσκηση 4
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα αποτελείται από το δεύτερο γράμμα κάθε τριπλέτας.

Για παράδειγμα:

Έστω η ακολουθία: ```CAGTGACGTACCGTAGGGCGTAGCGTAACG```

```
Η ακολουθία:
CAGTGACGTACCGTAGGGCGTAGCGTAACG

Σε τριπλέτες:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG

Το δεύτερο γράμμα κάθε τριπλέτας είναι:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG
 |   |   |   |   |   |   |   |   |   |
 A   G   G   C   T   G   G   G   T   C


Άρα αν f είναι το όνομα της συνάρτησης που θα φτιάξετε, το αποτέλεσμα της εντολής:
f('CAGTGACGTACCGTAGGGCGTAGCGTAACG')

Θα πρέπει να είναι:
'AGGCTGGGTC'
```

Λύση:
```python
def f(x):
	return x[1::3]
```

### Άσκηση 5
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει το [CG content](https://en.wikipedia.org/wiki/GC-content) της ακολουθίας. Το GC content υπολογίζεται με βάση τον παρακάτω τύπο:

![img](https://i.imgur.com/oRNebOT.png)

Όπου A,C,G,T είναι το πλήθος των A,C,G,T που υπάρχουν στην ακολουθίας. 

Λύση:
```python
def f(x):
	C = x.count('C')
	G = x.count('G')
	return (C+G) / len(x)
```

### Άσκηση 6
Φτάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα 2 αριθμούς. Ο πρώτος αναπαριστάει τον βαθμό ενός μαθητή στη πρόοδο ενός μαθήματος και ο δεύτερος τον βαθμό στο τελικό διαγώνισμα. Η πρόοδος μετράει για το 40% του τελικού βαθμού και το τελικό διαγώνισμα μετράει για το 60%. Η βάση του μαθήματος είναι το 5. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο μαθητής περνάει το μάθημα. 
* ```False``` αν ο μαθητής ΔΕΝ περνάει το μάθημα. 


Λύση:
```python
def f(a,b):
	return 0.6*a + 0.4*b > 0.5
```

### Άσκηση 7
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν η ακολουθία αποτελείται από 2 αντίγραφα
* ```False``` αν η ακολουθία ΔΕΝ αποτελείται από 2 αντίγραφα.

Μία ακολουθία αποτελείται από δύο αντίγραφα αν το 1ο μισό της είναι ίδιο με το δεύτερο μισό της. Για παράδειγμα:

```
f('AAACCCGGGAAACCCGGG') # Επιστρέφει True
το 1ο μισό της είναι: AAACCCGGG
Το 2ο μισό της είναι: AAACCCGGG


f('AAACCCGGGAAACCCGGT') # Επιστρέφει False
το 1ο μισό της είναι:  AAACCCGGG
το 2ο μισό της είναι:  AAACCCGGT

```

Υποθέστε ότι πάντα η ακολουθία έχει ζυγό (άρτιο) αριθμό από βάσεις. 

Λύση:
```python
def f(x):

	l = len(x)//2
	return x[:l] == x[l:]
```


### Άσκηση 8
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει:
* ```True``` , Αν οι πουρίνες (A ή G) είναι περισσότερες ή ίσες με τις πυριμιδίνες (T ή C). 
* ```False``` , Aν οι πουρίνες είναι λιγότερες από τις πυριμιδίνες. 

Λύση:
```python
def f(x):

	A = x.count('A')
	C = x.count('C')
	G = x.count('G')
	T = x.count('T')

	return A+G >= G+T 
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA η οποία σε κάποιο υπο-string της περιέχει ένα (και μόνο ένα) ORF ([Open Reading Frame](https://en.wikipedia.org/wiki/Open_reading_frame)). Η συνάρτηση θα επιστρέφει το ORF που περιέχει η ακολουθία. Για αυτή την άσκηση θα θεωρήσουμε ότι το stop codon μπορεί να είναι μόνο ```TAA```. Το start codon είναι: ```ATG```. 

Για παράδειγμα έστω η ακολουθία: 
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
```
Παρατηρούμε ότι:
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
             ^^^                        ^^^
              |                          |
            start                       stop
            codon                       codon
```


Θα πρέπει η συνάρτησή σας να επιστρέψει το ORF: ```ATGTTACCAGGTCCGAACTTATTGAGGTAA```

Σημείωση: Θεωρούμε ότι τα ```ATG``` και ```ΤΑΑ``` βρίσκονται πάντα σε θέσεις τριπλέτων, δεν χρειάζεται να το ελέγξετε αυτό. 

Λύση:
```python
def f(x):

	start = x.index('ATG')
	end = x.index('TAA') + 3
	return x[start:end]
```

### Άσκηση 10
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. H συνάρτησή σας θα πρέπει να επιστρέφει:
* ```True``` αν υπάρχει το start codon (```ATG```) στην ακολουθία **KAI** αν αυτό βρίσκεται σε θέση που να διαρείται με το 3 (δηλαδή όντως αποτελεί κωδικόνιο)
* ```False``` αν δεν ισχύει η παραπάνω συνθήκη. 

Για παράδειγμα:

```
f('AAAATGGGG') # Επιστρέφει True: To ATG είναι στη 3η θέση (μετρώντας από το 0) 
f('TAAAATGGGG') # Επιστρέφει False: To ATG είναι στη 4η θέση (μετρώντας από το 0)
f('AAACCCGGG') # Επιστρέφει False: Δεν υπάρχει το ATG μέσα στην ακολουθία
```

Λύση:
```python
# 1st solution 
def f(x):
	return x.count('ATG') > 0 and x.index('ATG')%3 == 0

# 2nd solution 
def f(x):
	return 'ATG' in x and x.index('ATG')%3 == 0

# 3rd solution 
def f(x):
	return x.find('ATG')%3 == 0

```


## Ασκήσεις 11-20

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα δύο παραμέτρους: το ΒΜΙ και το gender. Η συνάρτηση θα κάνει τους εξής υπολογισμούς:
* Αν το gender είναι ```"male"``` τότε:
   * Αν το BMI > 32 επιστρέφει ```"overweight"```
   * Αν το BMI <= 32 επιστρέφει ```"not overweight"```
* Αν το gender είναι ```"female"``` τότε:
   * Αν το BMI > 30 επιστρέφει ```"overweight"```
   * Αν το BMI <= 30 επιστρέφει ```"not overweight"```

Λύση:
```python
# 1st solution
def f(BMI, gender):
	if gender == 'male':
		if BMI > 32:
			return "overweight"
		return "not overweight"
	if gender == "female":
		if BMI > 30:
			return "overweight"
		return "not overweight"


#2nd solution
def f(BMI, gender):

	overweight = (gender == 'male' and BMI > 32) or (gender == 'female' and BMI > 30)
	if overweight:
		return 'overweight'

	return "not overweight"
```

### Άσκηση 12
Σύμφωνα με [αυτό το site](https://alen.space/basic-guide-nanosatellites/) υπάρχει μία κατηγοριοποίηση των δορυφόρων σε σχέση με το βάρος τους. Η κατηγοριοποίηση αυτή είναι:

```
    Large satellites: More than 1,000 kg
    Medium-sized satellites: 500-1,000 kg
    Small satellites:
        Minisatellite: 100-500 kg
        Microsatellite: 10-100 kg
        Nanosatellite: 1-10 kg
        Picosatellite: Less than 1 kg
```

Βλέπουμε λοιπόν ότι υπάρχουν τρεις βασικές κατηγορίες: ```"Large satellites"```, ```"Medium-sized satellites"``` και ```"Small satellites"```. Οι Small satellites χωρίζονται σε 4 υποκατηγορίες: ```Minisatellite```, ```Microsatellite```, ```Nanosatellite``` και ```Picosatellite```. 

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη μεταβλήτή: ```weight```. Ανάλογα με τον πίνακα παραπάνω η συνάρτηση θα επιστρέφει σε **ένα** string με τη κατηγορία και την υποκατηγορία (αν υπάρχει) του δορυφόρου με αυτή το βάρος. Για παράδειγμα:

```
f(1500) # Επιστρέφει: "Large satellite"
f(750)  # Επιστρέφει: "Medium-sized satellite"
f(200)  # Επιστρέφει: "Small satellite - Minisatellite"
f(0.5)  # Επιστρέφει: "Small satellite - Picosatellite"
``` 

Για τις οριακές τιμές επιστρέφουμε τη μικρότερη δυνατή κατηγορία. 

Λύση:
```python
def f(x):
	if x > 1000:
		return 'Large satellit'

	if x > 500:
		return 'Medium-sized satellites'

	if x > 100:
		return 'Small satellites - Minisatellite'

	if x > 10:
		return 'Small satellites - Microsatellite'

	if x > 1:
		return 'Small satellites - Nanosatellite'

	return 'Small satellites - Picosatellite'
```

### Άσκηση 13
Σε [αυτό το site](https://life-greece.gr/prostima-kok-gia-alkool-2019) υπάρχει ένας πίνακας με τα χρηματικά πρόστιμα για την οδήγηση υπό την επήρεια αλκοόλ. Αφού αναλογιστείτε πόσο επικίνδυνο είναι για εσάς και τους υπόλοιπους η οδήγηση υπό την επήρεια αλκοόλ φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο τη μεταβλητή alcohol. Η συνάρτηση θα επιστρέφει:

* Αν το alcohol < 0.25, επιστρέφει τον ακέραιο 0
* Αν το alcohol είναι από 0.25 μέχρι και 0.4 επιστρέφει τον ακέραιο 200
* Αν το alcohol είναι μεγαλύτερο από 0.4 μέχρι και 0.6 επιστρέφει τον ακέραιο 700
* Αν το alcohol είναι μεγαλύτερο από 0.6, επιστρέφει τον ακέραιο 3000

Λύση:
```python
def f(x):
	if alcohol < 0.25:
		return 0

	if alcohol <= 0.4:
		return 200

	if alcohol <= 0.6:
		return 700

	return 3000
```

### Άσκηση 14
Φτιάξτε μία συνάρτηση σε python, τέτοια ώστε όταν γράφω:
```
f(1)
```

Να επιστρέφει ```"Hello"```

Όταν γράφω:
```
f(f(1))
```
Να επιστρέφει ```"Mitsos"```

Όταν γράφω:
```
f(f(f(1)))
```
Να επιστρέφει: ```"Maria"```

```python
def f(x):

	if x == 1:
		return 'Hello'

	if x == 'Hello':
		return 'Mitsos'

	if x == 'Mitsos':
		return 'Maria'
```

### Άσκηση 15
Φτιάξτε δύο συναρτήσεις σε python με το όνομα ```f``` και ```g```. Και οι δύο συναρτήσεις θα πρέπει να παίρνουν σαν παράμετρο έναν ακέραιο και να επιστρέφουν έναν ακέραιο. Οι συναρτήσεις θα πρέπει να είναι τέτοιες ώστε η τιμή της έκφρασης:

```
f(g(1)+g(2)) + g(f(1)+f(2))
```

να είναι 3. 

Λύση:
```python
def f(x):
	return x

def g(x):
	return x-1
```

### Άσκηση 16
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο 2 αριθμούς: a,b. H συνάρτηση θα πρέπει να λύνει την εξίσωση ```ax+b=0``` με τον εξής τρόπο:

* Αν το a είναι 0 τότε:
   * Αν το b είναι 0 τότε επιστρέφει ```"TAYTOTHTA"```
   * Αν το b δεν είναι 0 τότε επιστρέφει: ```"ADYNATH"```
* Αν το a δεν είναι 0 τότε επιστρέφει τη τιμή: ```-b/a```.

Λύση:
```python
def f(a,b):
	if a == 0:
		if b == 0:
			return 'TAYTOTHTA'
		return 'ADYNATH'

	return -b/a
```

### Άσκηση 17
Ισχύει το εξής:

* Ένα ναυτικό μίλι είναι 1.852 χιλιόμετρα. 
* Ένα χιλιόμετρο είναι 0.62137 μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_km``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε χιλιόμετρα.

Φτιάξτε τη συνάρτηση ```km_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε χιλιόμετρα και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια. Σε αυτή τη συνάρτηση είναι υποχρεωτικό να χρησιμοποιήσετε τις συναρτήσεις ```nautical_miles_to_km``` και ```km_to_miles```.

Λύση:
```python
def nautical_miles_to_km(x):
	return x*1.852

def km_to_miles(x):
	return x*0.62137

def nautical_miles_to_miles(x):
	return km_to_miles(nautical_miles_to_km(x))
```

### Άσκηση 18
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει 3 παραμέτρους. Και οι 3 θα είναι αριθμοί. Η συνάρτηση θα επιστρέφει τον μεσαίο. Για παράδειγμα:

```
f(5,3,6) # Επιστρέφει: 5
f(3,4,5) # Επιστρέφει: 4
f(3,3,4) # Επιστρέφει: 3
f(3,3,3) # Επιστρέφει: 3
```

**Απαγορεύεται να χρησιμοποιήσετε ```max```, ```min```, ```sort```.**

Λύση:
```python
def f(x):
	if (b<=a and a<=c) or (c<=a and a<=b):
		return a
	if (a<=b and b<=c) or (c<=b and b<=a):
		return b

	return c

```

### Άσκηση 19
Φτιάξτε μία συνάρτηση με το όνομα ```reverse``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφή της (reverse). Για παράδειγμα:

```
reverse('ACGT') # Επιστρέφει: "TGCA"
reverse('AGTCCG') # Επιστρέφει: "GCCTGA"
```

Φτιάξτε μία συνάρτηση με το όνομα ```complement``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την συμπληρωματική ακολουθία της. Για να φτιάξετε τη συμπληρωματική ακολουθία πρέπει να κάνετε τις εξής αντικαταστάσεις:

* Αντικαταστήστε τα ```A``` με ```T```
* Αντικαταστήστε τα ```T``` με ```A```
* Αντικαταστήστε τα ```C``` με ```G```
* Αντικαταστήστε τα ```G``` με ```C```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να χρησιμοποιήσετε biopython ή κάποια βιβλιοθήκη που κάνει αυτό. 
* Hint: 

Έστω το string ```"mitsos"```. Πως θα αντικαταστούσατε το "s" με "ο" και τα "ο" με "s" ;
Αν κάνετε:
```
a = 'mitsos'
a = a.replace('s', 'o')
a = a.replace('o', 's')
print (a)
```
Το αποτέλεσμα είναι: ```"mitsss"``` (γιατί;)

Ένα κόλπο είναι το εξής:
```
a = 'mitsos'
a = a.replace('s', '1')
a = a.replace('o', '2')
a = a.replace('1', 'o')
a = a.replace('2', 's')
print (a)
```

Λύση:
```python

def reverse(x):
	return x[::-1]

def complement(x):
	t = x.replace('A', '1').replace('C', '2').replace('G', '3').replace('T', '4')
	t = t.replace('1', 'T').replace('2', 'G').replace('3', 'C').replace('4', 'A')

	return t
```

### Άσκηση 20
Φτιάξτε μία συνάρτηση με το όνομα ```reverse_complement``` η οποία θα παίρνει σαν όρισμα μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφη συμπληρωματική ακολουθία της. Για παράδειγμα:

```
f('AGTCCG') # Επιστρέφει: "CGGACT" 
```

Μπορείτε να επιβεβαίωσετε τα αποτελέσματά σας με [αυτό το online tool](http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html).

Συνίσταται (δεν είναι υποχρεωτικό) να χρησιμοποιήσετε τις συναρτήσεις ```reverse``` και ```complement``` της άσκησης 19. 

Λύση:
```python
def reverse_complement(x):
	return complement(reverse(x))
```

## Ασκήσεις 21-30

**Για τις ασκήσεις 21-25 δίνεται η παρακάτω συνάρτηση**

```python
import requests

def get_tumor_gene_names():
	r = requests.get('http://mygene.info/v3/query?q=tumor&fields=symbol&size=1000&species=human')
	j = r.json()

	return [x['symbol'] for x in j['hits']]
```

Η συνάρτηση αυτή χρειάζεται το πακέτο requests της python. Αν δεν είναι εγκαταστημένο στον υπολογιστή σας μπορείτε να το εγκαταστήσετε τρέχoντας σε ένα κελί στο jupyter:

```bash
!pip install requests
```

Η συνάρτηση ```get_tumor_gene_names()``` επιστρέφει μία λίστα με γονίδια τα οποία έχουν εντοπιστεί ότι εμπλέκονται στον καρκίνο.

### Άσκηση 21
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα με strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα περιέχει τα strings της παραμέτρου τα οποία ξεκινάνε από ```"IL"```

Χρησιμοποιώντας τη συνάρτηση την οποία φτιάξατε και τη συνάρτηση ```get_tumor_gene_names()``` απαντήστε στην ερώτηση: Ποια γονίδια που εμπλέκονται στον καρκίνο είναι ιντερλευκίνες;

### Άσκηση 22
Φτιάξτε μία συνάρτηση με το όνομα ```ask_22_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα έχει τα στοιχεία της περαμέτρου αλλά θα είναι ταξινομημένη με βάση το μήκος του string (από το μικρότερο στο μεγαλύτερο). 

Χρησιμοποιώντας τη συνάρτηση που μόλις φτιάξατε (τη ```ask_22_a```) και τη ```get_tumor_gene_names()```, φτιάξτε μία άλλη συνάρτηση με το όνομα ```ask_22_b``` η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιαστρέφει την απάντηση στην ερώτηση: Ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο;

### Άσκηση 23
Φτιάξτε μία συνάρτηση με το όνομα ```ask_23_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει τη λίστα της περαμέτρου όπου όμως σε κάθε στοιχείο της θα έχετε αφαιρέσει όλους τους αριθμούς. Για παράδειγμα θα πρέπει:

```python
l = ['C1QTNF3', 'CD274', 'TNFRSF21']
f(l) # Επιστρέφει: ['CQTNF', 'CD', 'TNFRSF']
```
Χρησιμοποιώντας τη συνάρτηση ```ask_23_a```, τη συνάρτηση ```ask_22_a``` της άσκησης 22 και τη συνάρτηση ```get_tumor_gene_names()```, φτιάξτε μία νέα συνάρτηση με το όνομα ```ask_23_b``` η οποία δεν θα παίρνει κάποιο όρισμα. Η συνάρτηση θα επιστρέφει την απαντήση στην ερώτηση: Αν αφαιρέσουμε τους αριθμούς από τα ονόματα των γονιδίων, ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο; (Τυπώστε τα αλλαγμένα ονόματα)

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι το πλήθος των γονιδίων που εμπλέκονται στον καρκίνο και ΔΕΝ έχουν κάποιον αριθμό στον όνομά τους. 

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει το στοιχείο της λίστας που έχει το μικρότερο μήκος. Αν δύο ή περισσότερα στοιχεία έχουν το ίδιο μικρότερο μήκος, τότε θα επιστρέφει αυτό που είναι μικρότερο αλφαβητικά. Για παράδειγμα:

```python
a =['lll', 'kkk', 'aaaa']

f(a) # Επιστρέφει "kkk" (είναι το μικρότερα αλφαβητικά και έχει το μικρότερο δυνατό μήκος)
f(get_tumor_gene_names()) # Επιστρέφει: ANG 

```

Αν χρησιμοποιήσετε 2 φορές τη sorted στην Άσκηση 25, χάνετε 2 μονάδες (8/10)

**Για τις ασκήσεις 26-30 δίνεται η παρακάτω συνάρτηση:**

```python
import requests

def get_tumour_genes_pos():
    url = 'http://mygene.info/v3/query?q=tumor'
    url += '&fields=symbol,genomic_pos.chr,genomic_pos.start,genomic_pos.end'
    url += '&size=1000&species=human'
    
    r = requests.get(url)
    j = r.json()

    list_1 = [
    	[
        	x['symbol'], 
        	(x['genomic_pos'][0] if type(x['genomic_pos']) is list else x['genomic_pos']),
    	] for x in j['hits'] if 'genomic_pos' in x]

    list_2 = [
    	[
    		x[0], x[1]['chr'], x[1]['start'], x[1]['end']
    	] for x in list_1 if not 'CHR' in x[1]['chr']]

    return list_2
```

Αν τρέξετε αυτή τη συνάρτηση θα επιστρέψει πάλι τα γονίδια τα οποία έχουν εμπλακεί στον καρκίνο αλλά αυτή τη φορά για κάθε γονίδιο θα έχουμε μία λίστα. 

Για παράδειγμα, ας τυπώσουμε τα πρώτα δέκα γονίδια:
```python
genes = get_tumour_genes_pos()
genes[:10]
```
Τυπώνει (ίσως σε εσάς να τυπώσει διαφορετική λίστα):
```
[['TPD52', '8', 80034745, 80231232],
 ['TP53', '17', 7661779, 7687538],
 ['TSG101', '11', 18468336, 18526951],
 ['TP63', '3', 189631389, 189897276],
 ['TP73', '1', 3652516, 3736201],
 ['TUSC3', '8', 15417215, 15766649],
 ['TUSC7', '3', 116709235, 116723581],
 ['PTTG2', '4', 37960398, 37961128],
 ['TUSC8', '13', 44400250, 44405984],
 ['TUSC1', '9', 25676389, 25678440]]
```

* το 1ο στοιχείο είναι το όνομα ενός γονιδίου
* το 2ο στοιχείο είναι το χρωμόσωμα στο οποίο ανήκει
* το 3ο στοιχείο είναι η αρχή του γονιδίου πάνω στο χρωμόσωμα
* το 4ο στοιχείο είναι το τέλος του γονιδίου πάνω στο χρωμόσωμα 


### Άσκηση 26
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονιδίου με το μεγαλύτερο μήκος. Το μήκος ενός γονιδίου είναι η διαφορά του τέλους από την αρχή του. Για παράδειγμα το μήκος του γονιδίου TPD52 είναι: 80231232-80034745=196487

### Άσκηση 27
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει μία λίστα με τα ονόματα των γονιδίων της λίστας της παραμέτρου ταξινομημένα ανάλογα με τη θέση τους στο γονιδίωμα. Πρώτα πάνε τα γονίδια που είναι στο χρωμόσωμα 1, μετά τα γονίδια που είναι στο χρωμόσωμα 2, ... μετά το χρωμόσωμα 22 μετά το Χ και στο τέλος το Υ. Τα γονίδια που είναι στο ίδιο χρωμόσωμα ταξινομούνται με βάση την θέση της αρχής τους στο χρωμόσωμά τους. 

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το μέσο όρο του μήκους των γονιδίων που περιέχει. 

Μέσος όρος της λίστας ```a = [4,5,6,6]``` είναι ```sum(a)/len(a)```

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()``` και η δεύτερη θα είναι το όνομα ενός χρωμοσώματος (π.χ. ```"4"```). H συνάρτηση θα επιστρέφει το πλήθος των γονιδίων της λίστας που ανήκουν σε αυτό το χρωμόσωμα.


π.χ.
```python
f(genes, '4') # Επιστρέφει 32
f(genes, '1') # Επιστρέφει 94 
f(genes, '21') # Επιστρέφει 8
```

### Άσκηση 30
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα, όπως αυτή που επιστρέφει η συνάρτηση ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονίδιου του οποίου το μήκος έχει τη μικρότερη απόσταση από το μέσο όρο του μήκους όλων των γονιδίων. 

Πως βρίσκουμε την απόσταση μεταξύ των αριθμών ```a``` και ```b```: ```abs(a-b)```. 

### Άσκηση 31
Γράψτε μία συνάρτηση η οποία θα παίρνει ως όρισμα 3 ακέραιους αριθμούς τους a,b,c. Η συνάρτηση θα επιστρέφει το άθροισμα όλων των αριθμών από το a μέχρι και το b οι οποίοι διαιρούνται με το c. Για παράδειγμα:

```
f(23, 258, 7) # επιστρέφει 4620
```

### Άσκηση 32
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι μία λίστα με αριθμούς. Η συνάρτηση θα επιστρέφει το γινόμενο των αντίστροφων των στοιχείων της λίστας τα οποία δεν είναι 0. Ο αντίστροφος ενός αριθμού a είναι το 1/a.  

Για παράδειγμα:

f([2, 4, 0, 0.1]) # επιστρέφει 1/2 * 1/4 * 1/0.1 = 1.25 

### Άσκηση 33
Ένας πληθυσμός με το όνομα Α αποτελείται από 20 ανθρώπους. Σε αυτούς τους ανθρώπους κάναμε γονοτύπηση σε 10 γενετικούς τόπους. Όλοι οι γονότυποι είναι δι-αλληλικοί (biallelic). Κάθε ένας από τους 10 γενετικούς τόπους έχει όνομα Μ1, Μ2, ... Μ10. Τα αποτελέσματα που πήραμε υπάρχουν σε αυτή τη λίστα:

```python
pop_A = [
	['M1', 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1],
	['M2', 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0],
	['M3', 1, 1, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1],
	['M4', 1, 1, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
	['M5', 0, 0, 2, 2, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 2],
	['M6', 0, 0, 1, 0, 2, 0, 0, 0, 1, 1, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0],
	['M7', 0, 0, 2, 1, 1, 1, 0, 2, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
	['M8', 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 2],
	['M9', 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 1, 1, 1, 1, 0, 2, 1, 0, 2, 1],
	['M10', 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]
]
```

Σε αυτή τη λίστα οι αριθμοί 0,1,2 σημαίνουν:
* 0: Ο γονότυπος είναι ομόζυγος στο πρωτεύον αλλήλιο
* 1: Ο γονότυπος είναι ετερόζυγος
* 2: Ο γονότυπος είναι ομόζυγος στο δευτερεύον αλλήλιο.

Ή αλλιώς τα 0,1,2 είναι το πλήθος των δευτερεύοντων αλλήλιων που έχει ο αντίστοιχος γονότυπος. 

Φτιάξτε μία συνάρτηση ο οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως η ```pop_A```. Η συνάρτηση θα επιστρέφει το όνομα του γονότυπου με τη μεγαλύτερη αλληλική συχνότητα του δευτερεύοντος αλλήλιου. Για παράδειγμα θα πρέπει:

```python
f(pop_A) # Επιστρέφει 'Μ9'
```

### Άσκηση 34
Κάνουμε τον ίδιο πείραμα σε έναν άλλο πληθυσμό ο οποίος όμως τώρα έχει 25 άτομα. Τα αποτελέσματα της γονοτύπησης υπάρχουν στη παρακάτω λίστα: 

```python
pop_B = [
	['M1', 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1], 
	['M2', 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 2, 0, 0, 0],
	['M3', 1, 1, 0, 2, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1],
	['M4', 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 2],
	['M5', 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 2, 1, 1, 0, 1, 0, 0, 0, 0],
	['M6', 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 2, 1, 0],
	['M7', 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 2, 0, 2, 2],
	['M8', 0, 2, 0, 0, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 2, 0, 1, 0, 0],
	['M9', 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 1, 0],
	['M10', 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 2, 2, 0, 2, 1, 0, 1, 2, 0, 0, 1, 0, 0, 1, 1]
]

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους Α και Β. Κάθε παράμετρος θα είναι μία λίστα όπως η pop_A και pop_B. Η συνάρτηση θα επιστρέφει το όνομα του γενετικού τόπου του οποίου η αλληλική συχνότητα του δευτερεύοντος αλλήλιου έχει τη μεγαλύτερη απόλυτη διαφορά μεταξύ των πληθυσμών Α και Β. 

### Άσκηση 35
[Αυτό το άρθρο της wikipedia](https://en.wikipedia.org/wiki/Genetic_distance) έχει έναν κατάλογο με μετρικές για την μέτρηση της γενετικής απόστασης μεταξύ δύο πληθυσμών με βάση τις αλληλικές τους συχνότητες. Αυτό το άρθρο είναι αρκετά κακογραμμένο και μπορείτε να το αγνοήσετε!

Καταρχήν θα ορίσουμε τη αλληλική συχνότητα P<sub>γ,α,π</sub> ως τη συχνότητα του αλλήλιου α στον γενετικό τόπο γ στον πλυθυσμό π. Για παράδειγμα ο πληθυσμός pop_A (θα τον αναφέρουμε σαν Α) έχει για κάθε έναν από τους 10 γενετικούς τόπους, 2 διαφορετικά αλλήλια (το πρωτεύον και το δευτερεύον). Στον γενετικό τόπο ```Μ1``` έχουμε τον γονότυπο από 20 ανρθώπους:

```python
print (pop_A[0][1:])
[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1]
```

Εδώ παρατηρούμε οτι έχουμε 11 φορές το 0, 8 φορές το 1 και μία φορά το 2. Άρα:
* Το πρωτεύον αλλήλιο υπάρχει: 11\*2 + 8\*1 = 30 φορές.
* Το δευτερεύον αλλήλιο υπάρχει: 8\*1 + 1\*2 = 10 φορές. 

Άρα το P<sub>1,πρωτεύον,Α</sub> είναι 30/40 . Ή αλλιώς η συχνότητα του πρωτεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 30/40. Ομοίως: P<sub>1,δευτερεύον,Α</sub> είναι 10/40. Ή αλλιώς η συχνότητα του δευτερεύοντος αλλήλιου στον γενετικό τόπο 1 στον πληθυσμό Α είναι 10/40.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα Α και Β. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την ευκλίδεια απόσταση (Rogers Euclidean distance) μεταξύ των πληθυσμών ```A``` και ```B```, η οποία ορίζεται ως εξής:

* Για κάθε γενετικό τόπο j (Μ1 έως Μ10) υπολογίστες τα P<sub>j,δευτερεύον,Α</sub> και P<sub>j,δευτερεύον,Β</sub>. Στη συνέχεια υπολογίστε τη διαφορά τους και στη συνέχεια υπολογίστε το τετράγωνο αυτής της διαφοράς.
* Υπολογίστε το άθροισμα αυτού του τετραγώνου για όλους τους γενετικούς τόπους (Μ1 έως Μ10).
* Υπολογίστε (και επιστρέψτε) τη τετραγωνική ρίζα αυτού του αθροίσματος 

H τετραγωνική ρίζα του a είναι: ```a**0.5```


### Άσκηση 36
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```.  Η συνάρτηση θα επιστρέφει την "Nei's minimum genetic distance 1973" μεταξύ των πληθυσμών ```X``` και ```Y``` η οποία υπολογίζεται ως εξής [πηγή](https://dyerlab.github.io/applied_population_genetics/genetic-distances.html):


<!-- OLD ![img](https://i.imgur.com/qde8a4d.png) -->
<!-- 
I=\frac{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}p_{ij,y} \right ) \right ) }{\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,x}^{2} \right ) \right )}\sqrt{\sum_{i=1}^{L} \left ( \sum_{j=1}^{l_{i}} \left ( p_{ij,y}^{2} \right ) \right )}}
-->
![img](https://i.imgur.com/kpYmmcp.png)


Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* l<sub>i</sub> είναι το πλήθος από αλλήλια στον γενετικό τόπο i. Στη δική μας περίπτωση έχουμε πάντα 2 (bi-allelic)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει: 0.9886664715207936
```


### Άσκηση 37
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες με το όνομα X και Y. Οι λίστες θα έχουν την ίδια μορφή όπως και οι λίστες ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την "Cavalli-Sforza chord distance" μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο ([πηγή](https://www.montana.edu/kalinowski/documents/2002_Genetic_distances_review_MolecularEcology.pdf)):

<!-- 
	D=1-\sum_{j=1}^{2}\left ( \sum_{i=1}^{L} \left ( \frac{\sqrt{p_{ij,x}\cdot p_{ij,y}}}{L} \right ) \right )
-->
![img](https://i.imgur.com/jFdqr3e.png)

<!-- ![img](https://i.imgur.com/qm3WRxQ.png) -->

Όπου:
* L είναι το πλήθος από γενετικούς τόπους (10 στη περίπτωσή μας)
* p<sub>ij,x</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό X
* p<sub>ij,y</sub> είναι η συχνότητα του αλληλίου j στον γενετικό τόπο i, στον πληθυσμό Y

Δίνεται ότι:
```python
f(pop_A, pop_B) # Επιστρέφει 0.004909335749700872
```

### Άσκηση 38
Αφού έχετε φτιάξει τις φανταστικές συναρτήσεις σας, ζητάτε από έναν συνάδελφο να σας στείλει τα δεδομένα του. Ο συνάδελφος σας στέλνει την εξής λίστα:

```python
pop_C= [
   ['M1', 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 1, 0],
   ['Μ2', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 2, 0],
   ['M3', 1, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 0, 1, 1, 0, 2, 1, 0],
   ['M4', 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0], 
   ['M5', 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0],
   ['M6', 0, 0, 0, 0, 2, 0, 1, 1, 0, 1, 0, 4, 2, 1, 0, 1, 1, 0, 1, 1, 0, 1, 2, 0, 1],
   ['M7', 0, 0, 0, 2, 1, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0],
   ['M8', 2, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2],
   ['M9', 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 1, 2, 0, 1, 0, 0, 1, 2, 0, 0, 0, 1, 1, 0],
   ['M10', 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 1],
   ['M11', 0, 1, 0, 2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2],
   ['M12', 0, 1, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0]

]

```  

Με τρόμο παρατηρείτε ότι η λίστα έχει προβλήματα! Υπάρχει γονότυπος με αριθμό 4 και ένας άλλος με αριθμό 5! Επίσης ο γενετικός τόπος ```'Μ11'``` έχει λιγότερους γονότυπους από ότι οι υπόλοιποι γενετικοί τόποι! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρο θα είναι μία λίστα (με τη μορφή που έχουν οι λίστες pop_A, pop_B, pop_C). H συνάρτηση σας θα επιστρέφει:
* ```False``` αν όλοι οι γενετικοί τόποι δεν έχουν το ίδιο πλήθος από γονότυπους.
* ```False``` αν υπάρχει έστω και ένας γονότυπος του οποίου οι τιμές ΔΕΝ είναι 0,1,2
* ```True``` αν δεν ισχύει καμία από τις παραπάνω συνθήκες. 

Για παράδειγμα θα πρέπει:
```python
f(pop_A) # Επιστρέφει True
f(pop_B) # Επιστρέφει True
f(pop_C) # Επιστρέφει False
```


### Άσκηση 39
Αφού επικοινωνείτε με τον συνάδελφό σας, του καταδεικνύετε τα λάθη που έχει κάνει! Ο συνάδελφος σας ζητάει συγγνώμη και σας στέλνει διορθωμένη τη λίστα. Η νέα λίστα είναι η εξής:

```python
pop_D = [
	['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10'], 
	[0, 2, 0, 0, 1, 1, 1, 0, 1, 0], 
	[1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 
	[0, 0, 2, 0, 1, 2, 0, 0, 0, 1], 
	[0, 0, 0, 2, 2, 0, 0, 0, 0, 0], 
	[0, 0, 0, 2, 1, 0, 1, 0, 0, 0], 
	[1, 2, 0, 0, 0, 2, 0, 0, 2, 0], 
	[0, 1, 0, 0, 0, 1, 0, 0, 0, 0], 
	[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], 
	[1, 2, 0, 0, 0, 0, 1, 0, 0, 0], 
	[0, 1, 0, 1, 0, 0, 1, 0, 0, 2], 
	[0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
	[1, 1, 2, 0, 2, 0, 1, 0, 0, 0], 
	[0, 1, 2, 0, 2, 1, 1, 0, 0, 2], 
	[0, 0, 1, 0, 0, 1, 2, 1, 0, 2], 
	[0, 0, 1, 0, 2, 1, 0, 1, 1, 0], 
	[0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
	[0, 0, 1, 0, 0, 1, 1, 0, 1, 1], 
	[0, 0, 0, 0, 2, 2, 0, 2, 0, 0], 
	[1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 
	[1, 0, 0, 2, 1, 1, 0, 1, 2, 2], 
	[1, 2, 0, 1, 0, 1, 0, 0, 1, 0], 
	[0, 0, 1, 0, 1, 1, 0, 1, 0, 0], 
	[0, 0, 2, 0, 2, 0, 0, 0, 1, 0], 
	[0, 1, 0, 1, 2, 0, 1, 0, 1, 0], 
	[0, 0, 2, 1, 1, 0, 0, 2, 1, 0],
]
```

Πάλι παρατηρείτε ότι κάτι δεν πάει καλά.. Παίρνετε τηλέφωνο τον συνάδελφο και σας εξηγεί ότι η νέα λίστα έχει σε κάθε υπολίστα έναν άνθρωπο. Η πρώτη υπολίστα έχει τα ονόματα των γενετικών τόπων. Η 2η έχει τους γονότυπους για τον 1ο άνθρωπο, η 3η για τον δεύτερο, η 4η για τον τρίτο κτλ. Για παράδειγμα η δεύτερη υπολίστα: ```[0, 2, 0, 0, 1, 1, 1, 0, 1, 0]``` περιέχει τους γονότυπους για τον 1ο άνθρωπο. Οπότε ο 1ος άνθρωπος στον γενετικό τόπο ```Μ1``` έχει γονότυπο 0, στον γενετικό τόπο ```Μ2``` έχει γονότυπο 2, στον γενετικό τόπο ```Μ3``` έχει γονότυπο 0 κτλ.. 

Εξηγείτε στον συνάδελφο ότι οι αλγόριθμοί σας δέχονται λίστες με διαφορετική διάταξη. Ο συνάδελφός σας όμως δηλώνει ότι δεν έχει ιδέα πως να μετατρέψει τη λίστα στη μορφή που πρέπει γιατί δεν έχει παρακολουθήσει το μάθημα ΒΙΟΛ-494. Ευτυχώς εσείς έχετε! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως είναι η pop_D. Η συνάρτηση θα κάνει τους ανάλογους μετασχηματισμούς έτσι ώστε η λίστα να έχει τη μορφή που έχει η λίστα pop_A ή η λίστα pop_B. 

Για παράδειγμα: 
```python
f(pop_D) 
# Θα πρέπει να επιστρέφει τη λίστα:
[
	['M1', 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], 
	['M2', 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0], 
	['M3', 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 0, 0, 0, 0, 1, 2, 0, 2], 
	['M4', 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 1], 
	['M5', 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 1, 1, 0, 1, 2, 2, 1], 
	['M6', 1, 0, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 2, 0, 1, 1, 1, 0, 0, 0], 
	['M7', 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], 
	['M8', 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 2], 
	['M9', 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 2, 1, 0, 1, 1, 1], 
	['M10', 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0],
]

```

### Άσκηση 40 
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει μία λίστα με τους αριθμούς από τα ονόματα των γονιδίων που εμπλέκονται στον καρκίνο και το μέγεθός τους είναι μεγαλύτερο από 5000. Για παράδειγμα:

```python
f(genes, sizes, cancer) # Επιστρέφει [2, 3, 4, 5, 6, 9]
```

**Κάποιες σημειώσεις για τις υπόλοιπες ασκήσεις**
* Απαγορεύεται να χρησιμοποιήσετε μεταβλήτές με το όνομα: max, min, id, str, int, list, dict, tuple, set. Αυτά είναι ονόματα συναρτήσεων της python. Αν και η python αφήνει τη χρήση τους (κακώς..) σαν ονόματα μεταβλητών, αυτό έχει τη συνέπεια ότι μετά ΔΕΝ μπορείτε να τις χρησιμοποιήσετε. Δοκιμάστε:

```python
print (min([4,5,3])) #  Δουλεύει κανονικά 
min=5
print (min([4,5,3])) # Ουπς !
```

* Απαγορεύεται να χρησιμοποιήσετε μεταβλητή που ΔΕΝ ((έχει οριστεί στη συνάρτηση που ανήκει) 'Η (είναι παράμετρος της συνάρτησης)). Και αυτό σας αφήνει η python να το κάνετε, αλλά ειδικά σε αρχάριους προγραμματιστές δημιουργεί σύγχηση όσον αφορά τι πρέπει να βάλετε σε μία συνάρτηση και τι όχι. Για παράδειγμα: Μία συνάρτηση η οποία επιστρέφει αν o τελευταίος χαρακτήρας ενός string είναι αριθμός: 

Λάθος:
```python
a = 'asdfasdf3'
last = x[-1]

def f(x):
	is_it = last.is_digit() # To last έχει οριστεί έξω από τη συνάρτηση. Επίσης τι το κάνουμε το x της παραμέτρου;
	return is_it

```

Σωστό:
```python
def f(x):
	last = x[-1]
	is_it = last.is_digit()
	return is_it
```

Παρόλα αυτά εννοείται ότι επιτρέπεται να χρησιμοποιήσουμε συναρτήσεις που έχουν οριστεί έξω από τη συνάρτησή μας. 

### Άσκηση 41
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποίο θα έχει τα κλειδιά του Α που δεν υπάρχουν στο Β και τα κλειδιά του Β που δεν υπάρχουν στο Α, με τις αντίστοιχες τιμές τους. Για παράδειγμα:

```python
A = {
	'kwstas': 1,
	'george': 2,
	'elenh': 3,
}

B = {
	'mitsos': 2,
	'kwstas': 3,
	'elenh': 1,
}


f(A,B) 
# Επιστρέφει:

{
	'george': 2,
	'mitsos': 2,
}
# Το "kwstas" και το "mitsos" υπάρχουν και στα δύο dictionaries (A και Β) για αυτό δεν 
# υπάρχουν στο dictionary που επέστρεψε η συνάρτηση.
``` 

### Άσκηση 42
Φτιάξτε μία συνάρτηση η οποία να παίρνει δύο παράμετρους. Οι παράμετροι είναι και οι δύο dictionaries, τα Α και το Β. Τα dictionaries είναι τέτοια που οι τιμές τους είναι ακέραιοι. Η συνάρτηση θα πρέπει να επιστρέφει ένα νέο dictionary το οποία θα πρέπει να έχει ΜΟΝΟ τα κλειδιά που ανήκουν και στο Α και στο Β. Η τιμή του κάθε κλειδιού θα είναι ο μέσος όρος των τιμών αυτού του κλειδιού στα dictionary Α και Β. Για παράδειγμα:

```python
A = {
	'kwstas': 1,
	'george': 2,
	'elenh': 3,
}

B = {
	'mitsos': 2,
	'kwstas': 3,
	'elenh': 2,
}


f(A,B)
# Επιστρέφει:
{
	'kwstas': 2. # (1+3)/2
	'elenh': 2.5 # (2+3)/2
}

```

### Άσκηση 43
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει ένα dictionary όπου:
* τα κλειδιά θα είναι τα genes
* Οι τιμές θα είναι ένα dictionary με τα εξής ζευγάρια κλειδί/τιμή:
   * 'size': περιέχει τις τιμές του sizes
   * 'cancer': περιέχει τις τιμές του cancer 

Για παράδειγμα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
cancer = [True, True, True, True, True, True, True, False, True, False]

f(genes, sizes, cancer) 
# Επιστρέφει:
{
	'Gene_1': {'size': 2957, 'cancer': True},
	'Gene_2': {'size': 8379, 'cancer': True},
	...
	'Gene_10': {'size': 7745, 'cancer': False},
}
```

### Άσκηση 44
Φτιάξτε μία συνάρτηση η οποία θα κάνει το αντίθετο από ότι η άσκηση 43. Η συνάρτηση θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένα dictionary όπως αυτό που επιστρέφει η άσκηση 43. Η συνάρτηση θα επιστρέφει τρεις λίστες:
* Η πρώτη θα είναι τα κλειδιά του dictionary της παραμέτρου
* Η δεύτερη θα είναι η τιμή του κλειδιού "size", της κάθε τιμής του dictionary της παραμέτρου, 
* Η τρίτη θα είναι η τιμή του κλειδιού "size", της κάθε τιμής του dictionary της παραμέτρου.

Παράδειγμα:
```python
A = {
	'Gene_1': {'size': 2957, 'cancer': True},
	'Gene_2': {'size': 8379, 'cancer': True},
	'Gene_10': {'size': 7745, 'cancer': False},
}

f(A)

k,l,m  = f(A)

print (k) # τυπώνει: ['Gene_1', 'Gene_2', 'Gene_10']
print (l) # τυπώνει [2957, 8379, 7745]
print (m) # τυπώνει [true, True, False]

```

### Άσκηση 45 
Το [MESH](https://en.wikipedia.org/wiki/Medical_Subject_Headings) είναι ένα λεξικό το οποίο περιέχει ιατρικούς και βιολογικούς όρους. Το Mesh υπάρχει από τη δεκαετία του 1960, και τα τελευταία 10 χρόνια περίπου είναι διαθέσιμο μόνο από το διαδίκτυο. Μία εγγραφή στο MESH είναι ένα string όπως το παρακάτω:

```python

MESH_record = '''
RECTYPE = D
MH = Calcimycin
AQ = AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR
ENTRY = A-23187|T109|T195|LAB|NRW|NLM (1991)|900308|abbcdef
ENTRY = A23187|T109|T195|LAB|NRW|UNK (19XX)|741111|abbcdef
ENTRY = Antibiotic A23187|T109|T195|NON|NRW|NLM (1991)|900308|abbcdef
ENTRY = A 23187
ENTRY = A23187, Antibiotic
MN = D03.633.100.221.173
PA = Anti-Bacterial Agents
PA = Calcium Ionophores
MH_TH = FDA SRS (2014)
MH_TH = NLM (1975)
ST = T109
ST = T195
N1 = 4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-
RN = 37H9VM9WZL
RR = 52665-69-7 (Calcimycin)
PI = Antibiotics (1973-1974)
PI = Carboxylic Acids (1973-1974)
MS = An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.
OL = use CALCIMYCIN to search A 23187 1975-90
PM = 91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
HN = 91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)
MR = 20160527
DA = 19741119
DC = 1
DX = 19840101
UI = D000001
'''

```

Παρατηρούμε ότι αυτό το string έχει πολλές γραμμές. Κάθε γραμμή αρχίζει με το όνομα ενός πεδίου. Στη συνέχεια υπάρχει ένα ``` = ``` και στη συνέχεια η τιμή αυτού του πεδίου.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα string το οποίο θα αναπαριστάει μία εγγραφή στη MESH (όπως το παράδειγμα παραπάνω). Η συνάρτηση θα επιστρέφει ένα dictionary. Τα κλειδιά του dictionary θα είναι τα ονόματα των πεδίων της εγγραφής και οι τιμές του dictionary θα είναι οι τιμές αυτών των πεδίων. Για παράδειγμα:

```python
f(A)
# Επιστρέφει:

{
	 'RECTYPE': 'D',
	 'MH': 'Calcimycin',
	 'AQ': 'AA AD AE AG AI AN BI BL CF CH CL CS EC HI IM IP ME PD PK PO RE SD ST TO TU UR',
	 'ENTRY': 'A23187, Antibiotic',
	 'MN': 'D03.633.100.221.173',
	 'PA': 'Calcium Ionophores',
	 'MH_TH': 'NLM (1975)',
	 'ST': 'T195',
	 'N1': '4-Benzoxazolecarboxylic acid, 5-(methylamino)-2-((3,9,11-trimethyl-8-(1-methyl-2-oxo-2-(1H-pyrrol-2-yl)ethyl)-1,7-dioxaspiro(5.5)undec-2-yl)methyl)-, (6S-(6alpha(2S*,3S*),8beta(R*),9beta,11alpha))-',
	 'RN': '37H9VM9WZL',
	 'RR': '52665-69-7 (Calcimycin)',
	 'PI': 'Carboxylic Acids (1973-1974)',
	 'MS': 'An ionophorous, polyether antibiotic from Streptomyces chartreusensis. It binds and transports CALCIUM and other divalent cations across membranes and uncouples oxidative phosphorylation while inhibiting ATPase of rat liver mitochondria. The substance is used mostly as a biochemical tool to study the role of divalent cations in various biological systems.',
	 'OL': 'use CALCIMYCIN to search A 23187 1975-90',
	 'PM': '91; was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
	 'HN': '91(75); was A 23187 1975-90 (see under ANTIBIOTICS 1975-83)',
	 'MR': '20160527',
	 'DA': '19741119',
	 'DC': '1',
	 'DX': '19840101',
	 'UI': 'D000001'
 }

```


### Άσκηση 46

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένα θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει τον επόμενο πρώτο αριθμό ο οποίος είναι μεγαλύτερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 11
f(11) # Επιστρέφει 13
f(15) # Επιστρέφει 17
```

### Άσκηση 47
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιτρέψει τον μεγαλύτερο πρώτο αριθμό ο οποίος είναι μικρότερος από τη παράμετρο. Για παράδειγμα:

```python
f(10) # Επιστρέφει 7
f(100) # Eπιστρέφει 97
``` 

### Άσκηση 48
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει την απάντηση στο παρακάτω ερώτημα. Ας υποθέσουμε ότι έχουμε 1000 ευρώ και κάθε μήνα ξοδεύουμε το 10% του ποσού που έχουμε. Μετά από πόσους μήνες το ποσό που θα έχει μείνει θα είναι λιγότερο από 100 ευρώ;

### Άσκηση 49
Φτιάξτε μία συνάρτηση με το όνομα ```fact``` η οποία θα δέχεται μία παράμετρο. Η παράμετρος θα είναι ένας θετικός ακέραιος αριθμός. Η συνάρτηση θα επιστρέφει το παραγοντικό του αριθμού αυτού. Το παραγοντικό ενός αριθμού ```N```, συμβολίζεται με ```Ν!``` και είναι ίσο με το γινόμενο: ```1 * 2 * .. * Ν-1 * Ν```.

Ο [αριθμός e](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29) είναι ίσος με 2.718281828459...  Επίσης γνωρίζουμε ότι ο αριθμός αυτό μπορεί να προσεγγιστεί με την παρακάτω σειρά:

![img](https://i.imgur.com/I3mS3Hu.png)

Όσο περισσότερους όρους βάλουμε σε αυτή τη σειρά, τόσο καλύτερη προσέγγιση του e θα κάνουμε. Φτιάξτε λοιπόν μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα υπολογίζει προσεγγιστικά και θα επιστρέφει το ```e``` χρησιμοποιώντας τον παραπάνω μαθηματικό τύπο. Για τον υπολογισμό του e, προσθέστε όσους όρους χρειαστούν μέχρι ο τελευταίος όρος που θα προσθέσετε να γίνει μικρότερος από 0.0001. Συνίσταται να χρησιμοποιήσετε τη συνάρτηση ```fact```. 

### Άσκηση 50
Δίνεται η παρακάτω συνάρτηση:

```python
import requests

def get_disease_gene_names(disease):
	r = requests.get(f'http://mygene.info/v3/query?q={disease}&fields=symbol&size=1000&species=human')
	j = r.json()

	return {x['symbol'] for x in j['hits']}
```

Αυτή η συνάρτηση παίρνει σαν όρισμα ένα string το οποίο αναπαριστάει έναν φαινότυπο (ασθένεια ή μη) ή μία βιολογική λειτουργία. Η συνάρτηση επιστρέφει ένα σύνολο από γονίδια τα οποία έχουν συσχετιστεί με αυτόν το string. 

Φτιάξτε μία συνάρτηση η οποία δεν παίρνει κανένα όρισμα. Η συνάρτηση θα πρέπει να επιστρέφει ένα **σύνολο** με τα γονίδια τα οποία: Εμπλέκονται στη παχυσαρκία (```'obesity'```) KAI στον μεταβολισμό (```'metabolism'```) αλλά δεν έχουν συσχετιστεί με κάποιο λιπίδιο (```'lipids'```).



