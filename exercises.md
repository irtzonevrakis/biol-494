
# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.


## Σημειώσεις για τις ασκήσεις: 1-10
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** η χρήση της ```if``` (αν τη χρησιμοποιείσετε χάνετε τη μισή άσκηση)
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)

Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
	if n%2 == 1:
		return True
	else:
		return False

```

Τι να κάνετε:
```python
def f(n):
	return n%2 == 1
```


### Άσκηση 1
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι μονός θα απιτρέφει: ```True```
* Αν το υπόλοιπο της διαίρεσης του αριθμού με το 7 είναι ζυγός (άρτιος) θα επιστρέφει ```False```

### Άσκηση 2
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. 
* Αν ο αριθμός ανήκει στο διάστημα \[100,200\] (δηλαδή είναι μεγαλύτερος ή ίσος από το 100 και μικρότερος ή ίσος από το 200) η συνάρτηση θα επιστρέφει ```True```.
* Aν o αριθμός ΔΕΝ ανήκει στο διάστημα \[100, 200\] η συνάρτηση θα επιστρέφει ```False```.

### Άσκηση 3
Υπολογίστε και τυπώστε τις τιμές της συνάρτησης:

f(x)=-8x<sup>2</sup> + 5x - 2

Για x=5, x=6, x=7

### Άσκηση 4
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει ένα string το οποίο θα αποτελείται από το δεύτερο γράμμα κάθε τριπλέτας.

Για παράδειγμα:

Έστω η ακολουθία: ```CAGTGACGTACCGTAGGGCGTAGCGTAACG```

```
Η ακολουθία:
CAGTGACGTACCGTAGGGCGTAGCGTAACG

Σε τριπλέτες:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG

Το δεύτερο γράμμα κάθε τριπλέτας είναι:
CAG TGA CGT ACC GTA GGG CGT AGC GTA ACG
 |   |   |   |   |   |   |   |   |   |
 A   G   G   C   T   G   G   G   T   C


Άρα αν f είναι το όνομα της συνάρτησης που θα φτιάξετε, το αποτέλεσμα της εντολής:
f('CAGTGACGTACCGTAGGGCGTAGCGTAACG')

Θα πρέπει να είναι:
'AGGCTGGGTC'
```

### Άσκηση 5
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν string το οποίο αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει το [CG content](https://en.wikipedia.org/wiki/GC-content) της ακολουθίας. Το GC content υπολογίζεται με βάση τον παρακάτω τύπο:

![img](https://i.imgur.com/oRNebOT.png)

Όπου A,C,G,T είναι το πλήθος των A,C,G,T που υπάρχουν στην ακολουθίας. 

### Άσκηση 6
Φτάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα 2 αριθμούς. Ο πρώτος αναπαριστάει τον βαθμό ενός μαθητή στη πρόοδο ενός μαθήματος και ο δεύτερος τον βαθμό στο τελικό διαγώνισμα. Η πρόοδος μετράει για το 40% του τελικού βαθμού και το τελικό διαγώνισμα μετράει για το 60%. Η βάση του μαθήματος είναι το 5. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο μαθητής περνάει το μάθημα. 
* ```False``` αν ο μαθητής ΔΕΝ περνάει το μάθημα. 


### Άσκηση 7
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν η ακολουθία αποτελείται από 2 αντίγραφα
* ```False``` αν η ακολουθία ΔΕΝ αποτελείται από 2 αντίγραφα.

Μία ακολουθία αποτελείται από δύο αντίγραφα αν το 1ο μισό της είναι ίδιο με το δεύτερο μισό της. Για παράδειγμα:

```
f('AAACCCGGGAAACCCGGG') # Επιστρέφει True
το 1ο μισό της είναι: AAACCCGGG
Το 2ο μισό της είναι: AAACCCGGG


f('AAACCCGGGAAACCCGGT') # Επιστρέφει False
το 1ο μισό της είναι:  AAACCCGGG
το 2ο μισό της είναι:  AAACCCGGT

```

Υποθέστε ότι πάντα η ακολουθία έχει ζυγό (άρτιο) αριθμό από βάσεις. 

### Άσκηση 8
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. Η συνάρτηση θα επιστρέφει:
* ```True``` , Αν οι πουρίνες (A ή G) είναι περισσότερες ή ίσες με τις πυριμιδίνες (T ή C). 
* ```False``` , Aν οι πουρίνες είναι λιγότερες από τις πυριμιδίνες. 

### Άσκηση 9
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA η οποία σε κάποιο υπο-string της περιέχει ένα (και μόνο ένα) ORF ([Open Reading Frame](https://en.wikipedia.org/wiki/Open_reading_frame)). Η συνάρτηση θα επιστρέφει το ORF που περιέχει η ακολουθία. Για αυτή την άσκηση θα θεωρήσουμε ότι το stop codon μπορεί να είναι μόνο ```TAA```. Το start codon είναι: ```ATG```. 

Για παράδειγμα έστω η ακολουθία: 
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
```
Παρατηρούμε ότι:
```
TGCACTGGGGAAAATGTTACCAGGTCCGAACTTATTGAGGTAAGACAGA
             ^^^                        ^^^
              |                          |
            start                       stop
            codon                       codon
```


Θα πρέπει η συνάρτησή σας να επιστρέψει το ORF: ```ATGTTACCAGGTCCGAACTTATTGAGGTAA```

Σημείωση: Θεωρούμε ότι τα ```ATG``` και ```ΤΑΑ``` βρίσκονται πάντα σε θέσεις τριπλέτων, δεν χρειάζεται να το ελέγξετε αυτό. 

### Άσκηση 10
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα ένα string το οποίο θα αναπαριστάει μία ακολουθία DNA. H συνάρτησή σας θα πρέπει να επιστρέφει:
* ```True``` αν υπάρχει το start codon (```ATG```) στην ακολουθία **KAI** αν αυτό βρίσκεται σε θέση που να διαρείται με το 3 (δηλαδή όντως αποτελεί κωδικόνιο)
* ```False``` αν δεν ισχύει η παραπάνω συνθήκη. 

Για παράδειγμα:

```
f('AAAATGGGG') # Επιστρέφει True: To ATG είναι στη 3η θέση (μετρώντας από το 0) 
f('TAAAATGGGG') # Επιστρέφει False: To ATG είναι στη 4η θέση (μετρώντας από το 0)
f('AAACCCGGG') # Επιστρέφει False: Δεν υπάρχει το ATG μέσα στην ακολουθία
```

## Ασκήσεις 10-20

### Άσκηση 11
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα δύο παραμέτρους: το ΒΜΙ και το gender. Η συνάρτηση θα κάνει τους εξής υπολογισμούς:
* Αν το gender είναι ```"male"``` τότε:
   * Αν το BMI > 32 επιστρέφει ```"overweight"```
   * Αν το BMI <= 32 επιστρέφει ```"not overweight"```
* Αν το gender είναι ```"female"``` τότε:
   * Αν το BMI > 30 επιστρέφει ```"overweight"```
   * Αν το BMI <= 30 επιστρέφει ```"not overweight"```

### Άσκηση 12
Σύμφωνα με [αυτό το site](https://alen.space/basic-guide-nanosatellites/) υπάρχει μία κατηγοριοποίηση των δορυφόρων σε σχέση με το βάρος τους. Η κατηγοριοποίηση αυτή είναι:

```
    Large satellites: More than 1,000 kg
    Medium-sized satellites: 500-1,000 kg
    Small satellites:
        Minisatellite: 100-500 kg
        Microsatellite: 10-100 kg
        Nanosatellite: 1-10 kg
        Picosatellite: Less than 1 kg
```

Βλέπουμε λοιπόν ότι υπάρχουν τρεις βασικές κατηγορίες: ```"Large satellites"```, ```"Medium-sized satellites"``` και ```"Small satellites"```. Οι Small satellites χωρίζονται σε 4 υποκατηγορίες: ```Minisatellite```, ```Microsatellite```, ```Nanosatellite``` και ```Picosatellite```. 

Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο τη μεταβλήτή: ```weight```. Ανάλογα με τον πίνακα παραπάνω η συνάρτηση θα επιστρέφει σε **ένα** string με τη κατηγορία και την υποκατηγορία (αν υπάρχει) του δορυφόρου με αυτή το βάρος. Για παράδειγμα:

```
f(1500) # Επιστρέφει: "Large satellite"
f(750)  # Επιστρέφει: "Medium-sized satellite"
f(200)  # Επιστρέφει: "Small satellite - Minisatellite"
f(0.5)  # Επιστρέφει: "Small satellite - Picosatellite"
``` 

Για τις οριακές τιμές επιστρέφουμε τη μικρότερη δυνατή κατηγορία. 

### Άσκηση 13
Σε [αυτό το site](https://life-greece.gr/prostima-kok-gia-alkool-2019) υπάρχει ένας πίνακας με τα χρηματικά πρόστιμα για την οδήγηση υπό την επήρεια αλκοόλ. Αφού αναλογιστείτε πόσο επικίνδυνο είναι για εσάς και τους υπόλοιπους η οδήγηση υπό την επήρεια αλκοόλ φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο τη μεταβλητή alcohol. Η συνάρτηση θα επιστρέφει:

* Αν το alcohol < 0.25, επιστρέφει τον ακέραιο 0
* Αν το alcohol είναι από 0.25 μέχρι και 0.4 επιστρέφει τον ακέραιο 200
* Αν το alcohol είναι μεγαλύτερο από 0.4 μέχρι και 0.6 επιστρέφει τον ακέραιο 700
* Αν το alcohol είναι μεγαλύτερο από 0.6, επιστρέφει τον ακέραιο 3000

### Άσκηση 14
Φτιάξτε μία συνάρτηση σε python, τέτοια ώστε όταν γράφω:
```
f(1)
```

Να επιστρέφει ```"Hello"```

Όταν γράφω:
```
f(f(1))
```
Να επιστρέφει ```"Mitsos"```

Όταν γράφω:
```
f(f(f(1)))
```
Να επιστρέφει: ```"Maria"```

### Άσκηση 15
Φτιάξτε δύο συναρτήσεις σε python με το όνομα ```f``` και ```g```. Και οι δύο συναρτήσεις θα πρέπει να παίρνουν σαν παράμετρο έναν ακέραιο και να επιστρέφουν έναν ακέραιο. Οι συναρτήσεις θα πρέπει να είναι τέτοιες ώστε η τιμή της έκφρασης:

```
f(g(1)+g(2)) + g(f(1)+f(2))
```

να είναι 3. 


### Άσκηση 16
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν παράμετρο 2 αριθμούς: a,b. H συνάρτηση θα πρέπει να λύνει την εξίσωση ```ax+b=0``` με τον εξής τρόπο:

* Αν το a είναι 0 τότε:
   * Αν το b είναι 0 τότε επιστρέφει ```"TAYTOTHTA"```
   * Αν το b δεν είναι 0 τότε επιστρέφει: ```"ADHNATH"```
* Αν το a δεν είναι 0 τότε επιστρέφει τη τιμή: ```-b/a```.


### Άσκηση 17
Ισχύει το εξής:

* Ένα ναυτικό μίλι είναι 1.852 χιλιόμετρα. 
* Ένα χιλιόμετρο είναι 0.62137 μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_km``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε χιλιόμετρα.

Φτιάξτε τη συνάρτηση ```km_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε χιλιόμετρα και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια.

Φτιάξτε τη συνάρτηση ```nautical_miles_to_miles``` η οποία θα παίρνει σαν παράμετρο έναν αριθμό ο οποίος θα αναπαριστά μία απόσταση σε ναυτικά μίλια και θα επιστρέφει την ίδια απόσταση εκφρασμένη σε μίλια. Σε αυτή τη συνάρτηση είναι υποχρεωτικό να χρησιμοποιήσετε τις συναρτήσεις ```nautical_miles_to_km``` και ```km_to_miles```.

### Άσκηση 18
Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει 3 παραμέτρους. Και οι 3 θα είναι αριθμοί. Η συνάρτηση θα επιστρέφει τον μεσαίο. Για παράδειγμα:

```
f(5,3,6) # Επιστρέφει: 5
f(3,4,5) # Επιστρέφει: 4
f(3,3,4) # Επιστρέφει: 3
f(3,3,3) # Επιστρέφει: 3
```

**Απαγορεύεται να χρησιμοποιήσετε ```max```, ```min```, ```sort```.**

### Άσκηση 19
Φτιάξτε μία συνάρτηση με το όνομα ```reverse``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφή της (reverse). Για παράδειγμα:

```
reverse('ACGT') # Επιστρέφει: "TGCA"
reverse('AGTCCG') # Επιστρέφει: "GCCTGA"
```

Φτιάξτε μία συνάρτηση με το όνομα ```complement``` η οποία θα παίρνει σαν παράμετρο μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την συμπληρωματική ακολουθία της. Για να φτιάξετε τη συμπληρωματική ακολουθία πρέπει να κάνετε τις εξής αντικαταστάσεις:

* Αντικαταστήστε τα ```A``` με ```T```
* Αντικαταστήστε τα ```T``` με ```A```
* Αντικαταστήστε τα ```C``` με ```G```
* Αντικαταστήστε τα ```G``` με ```C```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να χρησιμοποιήσετε biopython ή κάποια βιβλιοθήκη που κάνει αυτό. 
* Hint: 

Έστω το string ```"mitsos"```. Πως θα αντικαταστούσατε το "s" με "ο" και τα "ο" με "s" ;
Αν κάνετε:
```
a = 'mitsos'
a = a.replace('s', 'o')
a = a.replace('o', 's')
print (a)
```
Το αποτέλεσμα είναι: ```"mitsss"``` (γιατί;)

Ένα κόλπο είναι το εξής:
```
a = 'mitsos'
a = a.replace('s', '1')
a = a.replace('o', '2')
a = a.replace('1', 'o')
a = a.replace('2', 's')
print (a)
```

### Άσκηση 20
Φτιάξτε μία συνάρτηση με το όνομα ```reverse_complement``` η οποία θα παίρνει σαν όρισμα μία ακολουθία DNA. H συνάρτηση θα επιστρέφει την αντίστροφη συμπληρωματική ακολουθία της. Για παράδειγμα:

```
f('AGTCCG') # Επιστρέφει: "CGGACT" 
```

Μπορείτε να επιβεβαίωσετε τα αποτελέσματά σας με [αυτό το online tool](http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html).

Συνίσταται (δεν είναι υποχρεωτικό) να χρησιμοποιήσετε τις συναρτήσεις ```reverse``` και ```complement``` της άσκησης 19. 

## Ασκήσεις 21-30

**Για τις ασκήσεις 21-25 δίνεται η παρακάτω συνάρτηση**

```python
import requests

def get_tumor_gene_names():
	r = requests.get('http://mygene.info/v3/query?q=tumor&fields=symbol&size=1000&species=human')
	j = r.json()

	return [x['symbol'] for x in j['hits']]
```

Η συνάρτηση αυτή χρειάζεται το πακέτο requests της python. Αν δεν είναι εγκαταστημένο στον υπολογιστή σας μπορείτε να το εγκαταστήσετε τρέχoντας σε ένα κελί στο jupyter:

```bash
!pip install requests
```

Η συνάρτηση ```get_tumor_gene_names()``` επιστρέφει μία λίστα με γονίδια τα οποία έχουν εντοπιστεί ότι εμπλέκονται στον καρκίνο.

### Άσκηση 21
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα με strings. Η συνάρτηση θα επιστρέφει τα strings της παραμέτρου τα οποία ξεκινάνε από ```"IL"```

Χρησιμοποιώντας τη συνάρτηση την οποία φτιάξατε και τη συνάρτηση ```get_tumor_gene_names()``` απαντήστε στην ερώτηση: Ποια γονίδια που εμπλέκονται στον καρκίνο είναι ιντερλευκίνες;

### Άσκηση 22
Φτιάξτε μία συνάρτηση με το όνομα ```ask_22_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει μία νέα λίστα η οποία θα έχει τα στοιχεία της περαμέτρου αλλά θα είναι ταξινομημένη με βάση το μήκος του string (από το μικρότερο στο μεγαλύτερο). 

Χρησιμοποιώντας τη συνάρτηση που μόλις φτιάξατε (τη ```ask_22_a```) και τη ```get_tumor_gene_names()```, φτιάξτε μία άλλη συνάρτηση με το όνομα ```ask_22_b``` η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιαστρέφει την απάντηση στην ερώτηση: Ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο;

### Άσκηση 23
Φτιάξτε μία συνάρτηση με το όνομα ```ask_23_a``` η οποία θα παίρνει μία παράμετρο. Αυτή η παράμετρος είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει τη λίστα της περαμέτρου όπου όμως σε κάθε στοιχείο της θα έχετε αφαιρέσει όλους τους αριθμούς. Για παράδειγμα θα πρέπει:

```python
l = ['C1QTNF3', 'CD274', 'TNFRSF21']
f(l) # Επιστρέφει: ['CQTNF', 'CD', 'TNFRSF']
```
Χρησιμοποιώντας τη συνάρτηση ```ask_23_a```, τη συνάρτηση ```ask_22_a``` της άσκησης 22 και τη συνάρτηση ```get_tumor_gene_names()```, φτιάξτε μία νέα συνάρτηση με το όνομα ```ask_23_b``` η οποία δεν θα παίρνει κάποιο όρισμα. Η συνάρτηση θα επιστρέφει την απαντήση στην ερώτηση: Αν αφαιρέσουμε τους αριθμούς από τα ονόματα των γονιδίων, ποια είναι τα 10 γονίδια με το μεγαλύτερο όνομα τα οποία εμπλέκονται στον καρκίνο; (Τυπώστε τα αλλαγμένα ονόματα)

### Άσκηση 24
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει έναν αριθμό ο οποίος θα είναι το πλήθος των γονιδίων που εμπλέκονται στον καρκίνο και ΔΕΝ έχουν κάποιον αριθμό στον όνομά τους. 

### Άσκηση 25
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα από strings. Η συνάρτηση θα επιστρέφει το στοιχείο της λίστας που έχει το μικρότερο μήκος. Αν δύο ή περισσότερα στοιχεία έχουν το ίδιο μικρότερο μήκος, τότε θα επιστρέφει αυτό που είναι μικρότερο αλφαβητικά. Για παράδειγμα:

```python
a =['lll', 'kkk', 'aaaa']

f(a) # Επιστρέφει f(a) "kkk" (είναι το μικρότερα αλφαβητικά και έχει το μικρότερο δυνατό μήκος)
f(get_tumor_gene_names()) # Επιστρέφει: ANG 

```

Αν χρησιμοποιήσετε 2 φορές τη sorted στην Άσκηση 25, χάνετε 2 μονάδες (8/10)

**Για τις ασκήσεις 26-30 δίνεται η παρακάτω συνάρτηση:**

```python
import requests

def get_tumour_genes_pos():
    url = 'http://mygene.info/v3/query?q=tumor'
    url += '&fields=symbol,genomic_pos.chr,genomic_pos.start,genomic_pos.end'
    url += '&size=1000&species=human'
    
    r = requests.get(url)
    j = r.json()

    list_1 = [
    	[
        	x['symbol'], 
        	(x['genomic_pos'][0] if type(x['genomic_pos']) is list else x['genomic_pos']),
    	] for x in j['hits'] if 'genomic_pos' in x]

    list_2 = [
    	[
    		x[0], x[1]['chr'], x[1]['start'], x[1]['end']
    	] for x in list_1 if not 'CHR' in x[1]['chr']]

    return list_2
```

Αν τρέξετε αυτή τη συνάρτηση θα επιστρέψει πάλι τα γονίδια τα οποία έχουν εμπλακεί στον καρκίνο αλλά αυτή τη φορά για κάθε γονίδιο θα έχουμε μία λίστα. 

Για παράδειγμα, ας τυπώσουμε τα πρώτα δέκα γονίδια:
```python
genes = get_tumour_genes_pos()
genes[:10]
```
Τυπώνει (ίσως σε εσάς να τυπώσει διαφορετική λίστα):
```
[['TPD52', '8', 80034745, 80231232],
 ['TP53', '17', 7661779, 7687538],
 ['TSG101', '11', 18468336, 18526951],
 ['TP63', '3', 189631389, 189897276],
 ['TP73', '1', 3652516, 3736201],
 ['TUSC3', '8', 15417215, 15766649],
 ['TUSC7', '3', 116709235, 116723581],
 ['PTTG2', '4', 37960398, 37961128],
 ['TUSC8', '13', 44400250, 44405984],
 ['TUSC1', '9', 25676389, 25678440]]
```

* το 1ο στοιχείο είναι το όνομα ενός γονιδίου
* το 2ο στοιχείο είναι το χρωμόσωμα στο οποίο ανήκει
* το 3ο στοιχείο είναι η αρχή του γονιδίου πάνω στο χρωμόσωμα
* το 4ο στοιχείο είναι το τέλος του γονιδίου πάνω στο χρωμόσωμα 


### Άσκηση 26
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονιδίου με το μεγαλύτερο μήκος. Το μήκος ενός γονιδίου είναι η διαφορά του τέλους από την αρχή του. Για παράδειγμα το μήκος του γονιδίου TPD52 είναι: 80231232-80034745=196487

### Άσκηση 27
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει τα ονόματα των γονιδίων της λίστα ταξινομημένα ανάλογα με τη θέση τους στο γονιδίωμα. Πρώτα πάνε τα γονίδια που είναι στο χρωμόσωμα 1, μετά τα γονίδια που είναι στο χρωμόσωμα 2, ... μετά το χρωμόσωμα 22 μετά το Χ και στο τέλος το Υ. Τα γονίδια που είναι στο ίδιο χρωμόσωμα ταξινομούνται με βάση την θέση της αρχής τους στο χρωμόσωμά τους. 

### Άσκηση 28
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το μέσο όρο του μήκους των γονιδίων που περιέχει. 

Μέσος όρος της λίστας ```a = [4,5,6,6]``` είναι ```sum(a)/len(a)```

### Άσκηση 29
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Η πρώτη θα είναι μία λίστα όπως η λίστα που επιστρέφει η ```get_tumour_genes_pos()``` και η δεύτερη θα είναι το όνομα ενός χρωμοσώματος (π.χ. ```"4"```). H συνάρτηση θα επιστρέφει το πλήθος των γονιδίων της λίστας που ανήκουν σε αυτό το χρωμόσωμα.


π.χ.
```python
f(genes, '4') # Επιστρέφει 32
f(genes, '1') # Επιστρέφει 94 
f(genes, '21') # Επιστρέφει 8
```

### Άσκηση 30
Φτιάξτε μία συνάρτηση η οποία παίρνει μία παράμετρο. Η παράμετρος είναι μία λίστα, όπως αυτή που επιστρέφει η συνάρτηση ```get_tumour_genes_pos()```. Η συνάρτηση θα επιστρέφει το όνομα του γονίδιου του οποίου το μήκος έχει τη μικρότερη απόσταση από το μέσο όρο του μήκους όλων των γονιδίων. 

Πως βρίσκουμε την απόσταση μεταξύ των αριθμών ```a``` και ```b```: ```abs(a-b)```. 

### Άσκηση 31
Γράψτε μία συνάρτηση η οποία θα παίρνει ως όρισμα 3 ακέραιους αριθμούς τους a,b,c. Η συνάρτηση θα επιστρέφει το άθροισμα όλων των αριθμών από το a μέχρι και το b οι οποίοι διαιρούνται με το c. Για παράδειγμα:

```
f(23, 258, 7) # επιστρέφει 4620
```

### Άσκηση 32
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα όρισμα. Το όρισμα θα είναι μία λίστα με αριθμούς. Η συνάρτηση θα επιστρέφει το γινόμενο των αντίστροφων των στοιχείων της λίστας τα οποία δεν είναι 0. Ο αντίστροφος ενός αριθμού a είναι το 1/a.  

Για παράδειγμα:

f([2, 4, 0, 0.1]) # επιστρέφει 1/2 * 1/4 * 1/0.1 = 1.25 

### Άσκηση 33
Ένας πληθυσμός με το όνομα Α αποτελείται από 20 ανθρώπους. Σε αυτούς τους ανθρώπους κάναμε γονοτύπηση σε 10 γενετικούς τόπους. Όλοι οι γονότυποι είναι δι-αλληλικοί (biallelic). Κάθε ένας από τους 10 γενετικούς τόπους έχει όνομα Μ1, Μ2, ... Μ10. Τα αποτελέσματα που πήραμε υπάρχουν σε αυτή τη λίστα:

```python
pop_A = [
	['M1', 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1],
	['M2', 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0],
	['M3', 1, 1, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 1],
	['M4', 1, 1, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
	['M5', 0, 0, 2, 2, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 2],
	['M6', 0, 0, 1, 0, 2, 0, 0, 0, 1, 1, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0],
	['M7', 0, 0, 2, 1, 1, 1, 0, 2, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0],
	['M8', 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 2],
	['M9', 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 1, 1, 1, 1, 0, 2, 1, 0, 2, 1],
	['M10', 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]
]
```

Σε αυτή τη λίστα οι αριθμοί 0,1,2 σημαίνουν:
* 0: Ο γονότυπος είναι ομόζυγος στο πρωτεύον αλλήλιο
* 1: Ο γονότυπος είναι ετερόζυγος
* 2: Ο γονότυπος είναι ομόζυγος στο δευτερεύον αλλήλιο.

Ή αλλιώς τα 0,1,2 είναι το πλήθος των δευτερεύοντων αλλήλιων που έχει ο αντίστοιχος γονότυπος. 

Φτιάξτε μία συνάρτηση ο οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως η ```pop_A```. Η συνάρτηση θα επιστρέφει το όνομα του γονότυπου με τη μεγαλύτερη αλληλική συχνότητα του δευτερεύοντος αλλήλιου. Για παράδειγμα θα πρέπει:

```python
f(pop_A) # Επιστρέφει 'Μ9'
```

### Άσκηση 34
Κάνουμε τον ίδιο πείραμα σε έναν άλλο πληθυσμό ο οποίος όμως τώρα έχει 25 άτομα. Τα αποτελέσματα της γονοτύπησης υπάρχουν στη παρακάτω λίστα: 

```python
pop_B = [
	['M1', 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 1, 0, 1, 0, 2, 0, 1, 0, 2, 0, 1], 
	['M2', 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 2, 0, 0, 0],
	['M3', 1, 1, 0, 2, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1],
	['M4', 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 2],
	['M5', 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 2, 1, 1, 0, 1, 0, 0, 0, 0],
	['M6', 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 2, 1, 0],
	['M7', 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 2, 0, 2, 2],
	['M8', 0, 2, 0, 0, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 2, 0, 1, 0, 0],
	['M9', 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 2, 1, 0],
	['M10', 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 2, 2, 0, 2, 1, 0, 1, 2, 0, 0, 1, 0, 0, 1, 1]
]

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους Α και Β. Κάθε παράμετρος θα είναι μία λίστα όπως η pop_A και pop_B. Η συνάρτηση θα επιστρέφει το όνομα του γενετικού τόπου του οποίου η αλληλική συχνότητα του δευτερεύοντος αλλήλιου έχει τη μεγαλύτερη απόλυτη διαφορά μεταξύ των πληθυσμών Α και Β. 

### Άσκηση 35
[Αυτό το άρθρο της wikipedia](https://en.wikipedia.org/wiki/Genetic_distance) έχει έναν κατάλογο με μετρικές για την μέτρηση της γενετικής απόστασης μεταξύ δύο πληθυσμών με βάση τις αλληλικές τους συχνότητες. Συγκεκριμένα το άρθρο αναφέρει:

> In all the formulae in this section, X and Y represent two different populations for which L loci have been studied. 

Με βάση τα δεδομένα μας, Χ είναι ο πληθυσμός pop_A, Υ είναι ο πληθυσμός pop_B και L είναι οι μεταλλάξεις Μ1 μέχρι και Μ10. 

Επίσης το άρθρο αναφέρει:

> Let X<sub>u</sub> represent the u<sup>th</sup> allele frequency at the l<sup>th</sup> locus. 

Για παράδειγμα το Χ<sub>3</sub> είναι η αλληλική συχνότητα του δευτερεύοντως αλληλίου στον γενετικό τόπο ```'Μ3'``` στον πληθυσμό ```pop_A```.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες όπως οι ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την ευκλίδεια απόσταση (Euclidean distance) μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο που εμφανίζεται στο άρθρο της wikipedia. 


### Άσκηση 36
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες όπως οι ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την "Nei's minimum genetic distance 1973" μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο που εμφανίζεται στο άρθρο της wikipedia. 

### Άσκηση 37
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 παραμέτρους. Και οι δύο παράμετροι θα είναι λίστες όπως οι ```pop_A``` και ```pop_B```. Η συνάρτηση θα επιστρέφει την "Cavalli-Sforza chord distance" μεταξύ των πληθυσμών ```pop_A``` και ```pop_B```, σύμφωνα με τον μαθηματικό τύπο που εμφανίζεται στο άρθρο της wikipedia. 

### Άσκηση 38
Αφού έχετε φτιάξει τις φανταστικές συναρτήσεις σας, ζητάτε από έναν συνάδελφο να σας στείλει τα δεδομένα του. Ο συνάδελφος σας στέλνει την εξής λίστα:

```python
pop_C= [
   ['M1', 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 1, 0],
   ['Μ2', 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 2, 0],
   ['M3', 1, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 2, 1, 0, 0, 0, 1, 1, 0, 2, 1, 0],
   ['M4', 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 2, 0, 0, 0], 
   ['M5', 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 1, 0],
   ['M6', 0, 0, 0, 0, 2, 0, 1, 1, 0, 1, 0, 4, 2, 1, 0, 1, 1, 0, 1, 1, 0, 1, 2, 0, 1],
   ['M7', 0, 0, 0, 2, 1, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0],
   ['M8', 2, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2],
   ['M9', 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 1, 2, 0, 1, 0, 0, 1, 2, 0, 0, 0, 1, 1, 0],
   ['M10', 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 1],
   ['M11', 0, 1, 0, 2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2],
   ['M12', 0, 1, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0]

]

```  

Με τρόμο παρατηρείτε ότι η λίστα έχει προβλήματα! Υπάρχουν γονότυπος με αριθμό 4 και ένας άλλος με αριθμό 5! Επίσης ο γενετικός τόπος ```'Μ11'``` έχει λιγότερους γονότυπους από ότι οι υπόλοιποι γενετικοί τόποι! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρο θα είναι μία λίστα (με τη μορφή που έχουν οι λίστες pop_A, pop_B, pop_C). H συνάρτηση σας θα επιστρέφει:
* ```False``` αν όλοι οι γενετικοί τόποι δεν έχουν το ίδιο πλήθος από γονότυπους.
* ```False``` αν υπάρχει έστω και ένας γονότυπος του οποίου οι τιμές ΔΕΝ είναι 0,1,2
* ```True``` αν δεν ισχύει καμία από τις παραπάνω συνθήκες. 

Για παράδειγμα θα πρέπει:
```python
f(pop_A) # Επιστρέφει True
f(pop_B) # Επιστρέφει True
f(pop_C) # Επιστρέφει False
```


### Άσκηση 39
Αφού επικοινωνείτε με τον συνάδελφό σας, του καταδεικνύετε τα λάθη που έχει κάνει! Ο συνάδελφος σας ζητάει συγγνώμη και σας στέλνει διορθωμένη τη λίστα. Η νέα λίστα είναι η εξής:

```python
pop_D = [
	['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10'], 
	[0, 2, 0, 0, 1, 1, 1, 0, 1, 0], 
	[1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 
	[0, 0, 2, 0, 1, 2, 0, 0, 0, 1], 
	[0, 0, 0, 2, 2, 0, 0, 0, 0, 0], 
	[0, 0, 0, 2, 1, 0, 1, 0, 0, 0], 
	[1, 2, 0, 0, 0, 2, 0, 0, 2, 0], 
	[0, 1, 0, 0, 0, 1, 0, 0, 0, 0], 
	[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], 
	[1, 2, 0, 0, 0, 0, 1, 0, 0, 0], 
	[0, 1, 0, 1, 0, 0, 1, 0, 0, 2], 
	[0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
	[1, 1, 2, 0, 2, 0, 1, 0, 0, 0], 
	[0, 1, 2, 0, 2, 1, 1, 0, 0, 2], 
	[0, 0, 1, 0, 0, 1, 2, 1, 0, 2], 
	[0, 0, 1, 0, 2, 1, 0, 1, 1, 0], 
	[0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
	[0, 0, 1, 0, 0, 1, 1, 0, 1, 1], 
	[0, 0, 0, 0, 2, 2, 0, 2, 0, 0], 
	[1, 1, 0, 1, 1, 0, 1, 0, 1, 0], 
	[1, 0, 0, 2, 1, 1, 0, 1, 2, 2], 
	[1, 2, 0, 1, 0, 1, 0, 0, 1, 0], 
	[0, 0, 1, 0, 1, 1, 0, 1, 0, 0], 
	[0, 0, 2, 0, 2, 0, 0, 0, 1, 0], 
	[0, 1, 0, 1, 2, 0, 1, 0, 1, 0], 
	[0, 0, 2, 1, 1, 0, 0, 2, 1, 0],
]
```

Πάλι παρατηρείτε ότι κάτι δεν πάει καλά.. Παίρνετε τηλέφωνο τον συνάδελφο και σας εξηγεί ότι η νέα λίστα έχει σε κάθε υπολίστα έναν άνθρωπο. Η πρώτη υπολίστα έχει τα ονόματα των γενετικών τόπων. Η 2η έχει τους γονότυπους για τον 1ο άνθρωπο, η 3η για τον δεύτερο, η 4η για τον τρίτο κτλ. Για παράδειγμα η δεύτερη υπολίστα: ```[0, 2, 0, 0, 1, 1, 1, 0, 1, 0]``` περιέχει τους γονότυπους για τον 1ο άνθρωπο. Οπότε ο 1ος άνθρωπος στον γενετικό τόπο ```Μ1``` έχει γονότυπο 0, στον γενετικό τόπο ```Μ2``` έχει γονότυπο 2, στον γενετικό τόπο ```Μ3``` έχει γονότυπο 0 κτλ.. 

Εξηγείτε στον συνάδελφο ότι οι αλγόριθμοί σας δέχονται λίστες με διαφορετική διάταξη. Ο συνάδελφός σας όμως δηλώνει ότι δεν έχει ιδέα πως να μετατρέψει τη λίστα στη μορφή που πρέπει γιατί δεν έχει παρακολουθήσει το μάθημα ΒΙΟΛ-494. Ευτυχώς εσείς έχετε! 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα όπως είναι η pop_D. Η συνάρτηση θα κάνει τους ανάλογους μετασχηματισμούς έτσι ώστε η λίστα να έχει τη μορφή που έχει η λίστα pop_A ή η λίστα pop_B. 

Για παράδειγμα: 
```python
f(pop_D) 
# Θα πρέπει να επιστρέφει τη λίστα:
[
	['M1', 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], 
	['M2', 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0], 
	['M3', 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 0, 0, 0, 0, 1, 2, 0, 2], 
	['M4', 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 1], 
	['M5', 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 1, 1, 0, 1, 2, 2, 1], 
	['M6', 1, 0, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 2, 0, 1, 1, 1, 0, 0, 0], 
	['M7', 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], 
	['M8', 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 2], 
	['M9', 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 2, 1, 0, 1, 1, 1], 
	['M10', 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0],
]

```

### Άσκηση 40 
Η λίστα:
```python
genes = ['Gene_1', 'Gene_2', 'Gene_3', 'Gene_4', 'Gene_5', 'Gene_6', 'Gene_7', 'Gene_8', 'Gene_9', 'Gene_10']
```
Περιέχει τα ονόματα από 10 γονίδια.

Η λίστα:
```python
sizes = [2957, 8379, 9365, 5377, 9243, 5636, 4984, 9238, 6779, 7745]
```
Περιέχει το μέγεθός τους. 

H λίστα:
```python
cancer = [True, True, True, True, True, True, True, False, True, False]
```
περιέχει το αν εμπλέκονται σε μελέτες με καρκίνο (True) ή όχι (False).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παραμέτρους. Και οι τρεις παράμετροι θα είναι λίστες με το ίδιο μέγεθος όπως οι λίστες ```genes```, ```sizes``` και ```cancer```. Η συνάρτηση θα επιστρέφει μία λίστα με τους αριθμούς από τα ονόματα των γονιδίων που εμπλέκονται στον καρκίνο και το μέγεθός τους είναι μεγαλύτερο από 5000. Για παράδειγμα:

```python
f(genes, sizes, cancer) # Επιστρέφει [2, 3, 4, 5, 6, 9]
```


