#  Λίστες
Οι [λίστες](https://el.wikipedia.org/wiki/%CE%9B%CE%AF%CF%83%CF%84%CE%B1_%28%CE%B1%CF%86%CE%B7%CF%81%CE%B7%CE%BC%CE%AD%CE%BD%CE%BF%CF%82_%CF%84%CF%8D%CF%80%CE%BF%CF%82_%CE%B4%CE%B5%CE%B4%CE%BF%CE%BC%CE%AD%CE%BD%CF%89%CE%BD%29) είναι ένα μία βασική έννοια της επιστήμης υπολογιστών. 

Στην ουσία είναι μια διατεταγμένη σειρά από δεδομένα. Διατεταγμένο = κάθε στοιχείο έχει τη θέση του (1η, 2η, ...)


```python
a = [1,2,3,4]
print (a)
```

    [1, 2, 3, 4]


Μία λίστα μπορεί να έχει στοιχεία διαφορετικού τύπου (αριθμοί, δεκαδικά, strings, ...)


```python
a = [1,2,3,"mitsos", 5, 7.77777778]
print (a)
```

    [1, 2, 3, 'mitsos', 5, 7.77777778]


Η προσπέλαση των στοιχείων μίας λίστας γίνεται ακριβώς όπως και με τα strings:


```python
a[0] # Το πρώτο στοιχείο
```




    1




```python
a[0:3] #  Όλα τα στοιχεία από το πρώτο μέχρι το τέταρτο (χωρίς το τέταρτο)
```




    [1, 2, 3]




```python
a[-1] # Το τελευταίο στοιχείο
```




    7.77777778




```python
a[-2:] # Το προτελευταίο στοιχείο
```




    [5, 7.77777778]



Ομοίως, μπορούμε να χρησιμοποιήσουμε τα διαστήματα. Έστω:


```python
b = [1,2,3,4,5,6]
```


```python
b[2:5:2] # Από το 3ο μέχρι το 6ο (χωρίς να πάρουμε ΚΑΙ το 6ο), με βήμα 2
```




    [3, 5]




```python
b[::2] # Από την αρχή μέχρι ΚΑΙ το τέλος με βήμα 2
```




    [1, 3, 5]




```python
b[:3] # Από την αρχή μέχρι το 4ο στοιχείο (χωρίς να πάρουμε ΚΑΙ το 4ο)
```




    [1, 2, 3]




```python
# Όλα τα παρακάτω είναι ισοδύναμα
print (b)
print (b[:])
print (b[::])
print (b[::1])
print (b[0:])
print (b[0::])
print (b[0::1])
print (b[:len(b)])
print (b[:len(b):])
print (b[0:len(b)])
print (b[0:len(b):1])
```

    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]



```python
b[-1:0:-1] # Από το τέλος μέχρι την αρχή (χωρίς να πάρουμε ΚΑΙ την αρχή)
```




    [6, 5, 4, 3, 2]




```python
b[-1::-1] # Από το τέλος μέχρι την αρχή (παίρνουμε και την αρχή)
```




    [6, 5, 4, 3, 2, 1]




```python
b[::-1] # Αυτό είναι ισοδύναμε με το παραπάνω
```




    [6, 5, 4, 3, 2, 1]



Όπως και τα strings έτσι και στις λίστες μπορούμε να εφαρμόσουμε τις ```len```, ```count```, ```index```.


```python
a = [1,2,3,"mitsos", 5, 7.77777778]
```


```python
len(a) # Το πλήθος όλων των στοιχείων της λίστας
```




    6




```python
a.count(1) # Πόσες φορές υπάρχει το 1 μέσα στη λίστα;
```




    1




```python
a.count(55) # Πόσες φορές υπάρχει το 55 μέσα στη λίστα;
```




    0




```python
a.index("mitsos") # Σε ποια θέση της λίστας εμφανίζεται το "mitsos"?
```




    3




```python
a.index(4) # Σε ποια θέση της λίστας εμφανίζεται το 4;
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-32-e644608c73eb> in <module>
    ----> 1 a.index(4) # Σε ποια θέση της λίστας εμφανίζεται το 4;
    

    ValueError: 4 is not in list


Μία λίστα μπορεί να έχει μέσα άλλες λίστες!


```python
a = [1,2, [3,4,5], 6, 7]
```


```python
len(a)
```




    5




```python
a[2]
```




    [3, 4, 5]




```python
a[1]
```




    2




```python
a[2][1]
```




    4



Μπορούμε να αλλάξουμε τα περιεχόμενα οποιουδήποτε στοιχείου μίας λίστας:


```python
a = [1,2,3,4,5]
a[2] = 8
print (a)
```

    [1, 2, 8, 4, 5]



```python
a[3] = ['Mitsos', 'Kwstas']
print (a)
```

    [1, 2, 8, ['Mitsos', 'Kwstas'], 5]


**Προσοχή!** αυτό δεν επιτρέπεται στα strings:


```python
a = 'Mitsos'
a[2] = 'k'
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-134-2320b677b6ef> in <module>
          1 a = 'Mitsos'
    ----> 2 a[2] = 'k'
    

    TypeError: 'str' object does not support item assignment


Αν θέλετε να διαβάσετετε περισσότερα σχετικά με το γιατί ισχύει αυτό κάντε google: 'Why are Python Strings Immutable?'

Υπάρχει επίσης η άδεια λίστα: ```[]```


```python
a = []
print (len(a))
```

    0


Μπορούμε να γράψουμε τις λίστες με πολλούς τρόπους:


```python
# Τα παρακάτω είναι ισοδύαναμα:
a = [1,2,3] 

a = [
    1,
    2,
    3,
]
```

**Προσοχή!** Δεν υπάρχει πρόβλημα αν βάλουμε ένα κόμμα στο τέλος μίας λίστας!


```python
# Αυτά τα δύο είναι ισοδύναμα:
print ([1,2,3]) 
print ([1,2,3,])
```

    [1, 2, 3]
    [1, 2, 3]


Οπότε αν βάλουμε ένα κόμμα στο τέλος δεν υπάρχει πρόβλημα. Υπάρχει όμως αν ΔΕΝ βάλουμε στη μέση:


```python
a = [
    'aaaa',
    'bbbb' # PROSOXH! auto einai 1 string (me to apo katw)
    'cccc'
]
print (len(a))
```

    2


Μία λίστα μπορεί να έχει μία λίστα, που έχει μία λίστα που έχει..


```python
a = [[]]
print (len(a))
```

    1



```python
a = [[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]
print (len(a))
```

    1



```python
a = [1,2,3,[],4]
```


```python
len(a)
```




    5




```python
a=3
b = [a,a,a+1, a/2]
print (b)
```

    [3, 3, 4, 1.5]


Μπορούμε να προσθέσουμε δύο λίστες:


```python
[1,2,3] + ["mitsos", "a"]
```




    [1, 2, 3, 'mitsos', 'a']



Μπορούμε να πολλαπλασιάσουμε μία λίστα με έναν αριθμό:


```python
[1,2,3] *4
```




    [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]



Δεν μπορούμε να πολλαπλασιάσουμε ή να αφαιρέσουμε δύο λίστες!


```python
[1,2,3] * [5,6]
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-50-4f81883a1dc4> in <module>
    ----> 1 [1,2,3] * [5,6]
    

    TypeError: can't multiply sequence by non-int of type 'list'



```python
[1,2,3] - ["mitsos", "a"]
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-51-d5954fea0119> in <module>
    ----> 1 [1,2,3] - ["mitsos", "a"]
    

    TypeError: unsupported operand type(s) for -: 'list' and 'list'


Η Μέθοδος ```list``` κάνει ότι μπορεί να μετατρέψει κάτι σε λίστα:


```python
list("mitsos")
```




    ['m', 'i', 't', 's', 'o', 's']




```python
list([1,2,3]) # Δεν κάνει τίποτα
```




    [1, 2, 3]



Δεν μπορούν να μετατραπούν τα πάντα σε λίστα:


```python
list(5)
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-54-0c7f5cd48ec1> in <module>
    ----> 1 list(5)
    

    TypeError: 'int' object is not iterable


Μία λίστα είναι πάντα True, εκτώς αν είναι άδεια:


```python
if [1,2,3]:
    print ("not empty")
```

    not empty



```python
if []:
    print ("not empty")
else:
    print ("is empty!")
```

    is empty!


### Σύγκριση strings

Όταν εφαρμόζονται σε strings, τότε τα συγκρίνουμε αλφαριθμητικά (λεκτικά). Ποιο μικρό θεωρείται αυτό που σε μία ταξινόμηση, παίρνει τη μικρότερη θέση:


```python
'ab' < 'fg'
```




    True




```python
'ab' < 'b'
```




    True




```python
'ab' < 'ac'
```




    True




```python
'ab' < 'a'
```




    False



Το άδειο string έχει τη πιο μικρή δυνατή τιμή


```python
'' < '0'
```




    True




```python
"A" < "a"
```




    True




```python
"05456745674" < "5"
```




    True




```python
'8' < '09'
```




    False



### O τελεστής in
Αυτός ο τελεστής ελέγχει αν υπάρχει "κάτι" "κάπου"


```python
'rak' in 'Heraklion'
```




    True




```python
'raki' in 'Heraklion'
```




    False




```python
'h' in 'Heraklion'
```




    False




```python
'H' in 'Heraklion'
```




    True




```python
1 in [1,2,3]
```




    True




```python
[1,2] in [1,2,3]
```




    False




```python
[1,2] in [1, [1,2], 3]
```




    True




```python
False in [1, True-True]
```




    True




```python
None in [3, None, 4]
```




    True




```python
'ra' in ['Heraklion']
```




    False




```python
[] in [1, [], 2]
```




    True



### map και filter

Μπορούμε να εφαρμόσουμε μία συνάρτηση σε όλα τα στοιχεία μία λίστας με τη συνάρτηση ```map```:


```python
def f(x):
    return x+1

a = [4,5,6]

list(map(f,a))
```




    [5, 6, 7]



Μπορούμε να πάρουμε ένα υποσύνολο των στοιχείων μία λίστας τα οποία έχουν μία ιδιότητα με τη συνάρτηση ```filter```. Η filter πρέπει να επιστρέφει κάτι που μπορεί να αποτιμηθεί ως ```True``` ή ```False```.  


```python
def is_even(x):
    # Επέστρεψε True / False ανάλογα αν το χ είναι άρτιο ή όχι.
    return x%2==0

a = [1,2,3,4,5,6,7,8,9]
list(filter(is_even,a))
```




    [2, 4, 6, 8]




```python
def is_first_vowel(x):
    # Επέστρεψε True / False ανάλογα αν το χ ξεκινάει (πρώτο γράμμα) από φωνήεν ή όχι.
    return x[0].lower() in 'αεηιουω'

a = ['Ηράκλειο', 'Θεσσαλονίκη', 'Αθήνα']
list(filter(is_first_vowel,a))
```




    ['Ηράκλειο', 'Αθήνα']



### Πράξεις πάνω σε λίστες
Σε λίστες μπορούμε να κάνουμε τις παρακάτω πράξεις:


```python
sum([2,3,4]) # Το άθροισμα όλων των στοιχείων της λίστας:
```




    9



**Προσοχή** Η ```sum``` πρέπει να έχει μόνο ```int``` ή ```float```


```python
sum(['a', 'b'])
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-68-0ca1e4efb8fe> in <module>
    ----> 1 sum(['a', 'b'])
    

    TypeError: unsupported operand type(s) for +: 'int' and 'str'



```python
min([3,5,4]) # Το μικρότερο στοιχείο
```




    3




```python
max(['heraklion', 'patras', 'athens']) # Το μεγαλύτερο στοιχείο
```




    'patras'




```python
max(['heraklion', 'patras', 't'])
```




    't'



Μία ιδιότητα που έχουν οι ```max```  και η ```min``` είναι ότι αν η λίστα περιέχει υπολίστες τότε ψάχνουν το μικρότερο στοιχείο στο πρώτο στοιχείο της υπολίστας. Αν υπάρχουν δύο ή περισσότερες υπολίστες με το ίδιο μικρότερο πρώτο στοιχείο τότε ψάχνουν στο δεύτερο κτλ.:


```python
min([[5, "b"], [7, "t"], [6, 'r'], [5, 'a']])
```




    [5, 'a']



Και αυτό γιατί:


```python
[5, 'a'] < [5, 'b']
```




    True



### Πρόσθεση και αφαίρεση στοιχείων σε μία λίστα
Θυμόμαστε ότι μπορύμε να προσθέσουμε δύο λίστες μεταξύ τους:


```python
[1,2,3] + ['Μίτσος', 7.8]
```




    [1, 2, 3, 'Μίτσος', 7.8]



Μπορούμε να χρησιμοποιήσουμε αυτή την ιδιότητα για να προσθέτουμε στοιχεία σε μία λίστα σε οποιοδήποτε σημείο:


```python
# Πρόσθεση στο τέλος:
a = [1,2,3]
a = a + ['Μήτσος']
print (a)
```

    [1, 2, 3, 'Μήτσος']


Θυμόμαστε ότι το ```a = a + b``` είναι ισοδύναμο με το ```a += b```:


```python
# Πρόσθεση στο τέλος:
a = [1,2,3]
a += ['Μήτσος']
print (a)
```

    [1, 2, 3, 'Μήτσος']



```python
# Πρόσθεση στην αρχή:
a = [1,2,3]
a = ['Μήτσος'] + a
print (a)
```

    ['Μήτσος', 1, 2, 3]



```python
# Πρόσθεση σε ένα οποιαδήποτε σημείο (χρησιμοποιούμε slicing):
a = [1,2,3]
a = a[:2] + ['Μήτσος'] + a[2:]
print (a)
```

    [1, 2, 'Μήτσος', 3]


Μπορούμε αντί για αυτά να χρησιμοποιήσουμε τις συναρτήσεις append, extend και insert:


```python
a = [1,2,3]
a.append('Mitsos') # ισοδύναμο με το a += ['Mitsos']
print (a)
```

    [1, 2, 3, 'Mitsos']



```python
a = [1,2,3]
a.extend(['Mitsos', 7.8]) # ισοδύναμο με το a += ['Mitsos', 7.8]
print (a)
```

    [1, 2, 3, 'Mitsos', 7.8]



```python
a = [1,2,3]
a.insert(2, 'Mitsos') # ισοδύναμε με το a = a[:2] + ['Mitsos'] + a[2:]
print (a)
```

    [1, 2, 'Mitsos', 3]


Για να αφαιρέσουμε ένα στοιχείο μπορούμε να χρησιμοποιήσουμε πάλι slicing:


```python
a = [1, 2, 'Mitsos', 3]
a = a[:2] + a[3:]
print(a)
```

    [1, 2, 3]


Μπορούμε όμως και να χρησιμοποιήσουμε τη ```del```:


```python
a = [1, 2, 'Mitsos', 3]
del a[2]
print (a)
```

    [1, 2, 3]


Ένας άλλος τρόπος είναι απλά να κάνουμε filter:


```python
a = [1, 2, 'Mitsos', 3]

def remove_mitsos(x):
    return x != 'Mitsos'

a=list(filter(remove_mitsos, a))
print(a)
```

    [1, 2, 3]


### Sorting
Με την εντολή ```sorted``` μπορούμε να ταξινομήσουμε μία λίστα:


```python
a = [3,4,5,3,2,1]
```


```python
sorted(a)
```




    [1, 2, 3, 3, 4, 5]



**Προσοχή!** η ```sorted``` ΔΕΝ αλλάζει τη λίστα. Αποθηκεύει το αποτέλεσμα σε μία άλλη μεταβλητή:


```python
a
```




    [3, 4, 5, 3, 2, 1]




```python
b = sorted(a)
```


```python
b
```




    [1, 2, 3, 3, 4, 5]



αν θέλουμε να αλλάξει η λίστα μας (sorting in place) χρησιμοποιούμε τη συνάρτηση sort:


```python
a = [3, 4, 5, 3, 2, 1]
a.sort()
print (a) # Η a άλλαξε!
```

    [1, 2, 3, 3, 4, 5]


Μπορούμε να ταξινομήσουμε μόνο λίστες που έχουν τον ίδιο τύπο δεδομένων:


```python
sorted(["b", "a", "c"])
```




    ['a', 'b', 'c']




```python
sorted(["b", "a", 100, "c"])
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-81-b245b7eeb5df> in <module>
    ----> 1 sorted(["b", "a", 100, "c"])
    

    TypeError: '<' not supported between instances of 'int' and 'str'


Μπορούμε να ταξινομήσουμε από το μεγαλύτερο προς το μικρότερο:


```python
sorted([3,4,5,2,3,4,5,2,1], reverse=True)
```




    [5, 5, 4, 4, 3, 3, 2, 2, 1]



Όπως και με τη ```min``` και τη ```max```, αν αυτό που ταξινομούμε είναι λίστα από λίστες (ή tuple), τότε ελέγχει πρώτα το πρώτο στοιχείο της υπολίστας. Αν είναι ίσο, τότε ελέγχει το δεύτερο κτλ:


```python
a = [
    ["mitsos", 50],
    ['gianni', 40],
    ['gianni', 30]
]
sorted(a)
```




    [['gianni', 30], ['gianni', 40], ['mitsos', 50]]



Στο παραπάνω παράδειγμα το ```['gianni', 30]``` είναι μικρότερο από το ```['gianni', 40]```:


```python
['gianni', 30] < ['gianni', 40]
```




    True



Πολλές φορές θέλουμε να ταξινομήσουμε μία λίστα που περιέχει υπολίστες αλλά θέλουμε η ταξινόμηση να γίνει όχι με βάση το πρώτο στοιχείο αλλά με βάση μία δική μας συνάρτηση. Π.χ. Έστω η λίστα: 


```python
a = [["gianni", 30, 20000], ["mitsos", 50, 4000], ["anna", 60, 100000]]
```

Ας υποθέσουμε ότι θέλουμε να ταξινομήσουμε τα στοιχεία της λίστας με βάση το τρίτο στοιχείο τους (20000, 4000, 100000). Προσέχτε ότι αν τρέξουμε τη ```sorted``` τότε δεν θα μας επιστρέψει αυτό που θέλουμε:


```python
sorted(a)
```




    [['anna', 60, 100000], ['gianni', 30, 20000], ['mitsos', 50, 4000]]



Εμείς θέλουμε το στοιχείο που έχει το 4000 να βγει πρώτο μετά το στοιχείο που έχει το 20000 να βγει δεύτερο και το στοιχείο που έχει το 100000 να βγει τελευταίο.

Σε αυτή τη περίπτωση μπορούμε να φτιάξουμε μία συνάρτηση η οποία όταν παίρνει ως όρισμα κάποιο στοιχείο μιας λίστας να μας επιστρέφει την τιμή μέσω της οποίας θα γίνει η ταξινόμηση:


```python
def sort_according_to_this(x):
    return x[2]
```

Αν τώρα βάλω σε αυτή τη συνάρτηση ένα στοιχείο της λίστας θα μου επιστρέψει το τρίτο στοιχείο του, το οποίο είναι και αυτό που θέλω να βασιστεί η ταξινόμηση:


```python
sort_according_to_this(a[0])
```




    20000




```python
sort_according_to_this(a[1])
```




    4000




```python
sort_according_to_this(a[2])
```




    100000



Τώρα μπορώ να περάσω ως όρισμα τη συνάρτηση ```sort_according_to_this``` στη ```sorted``` και να ταξινομήσει τη λίστα ```a``` με βάση το τρίτο στοιχείο του κάθε στοιχείου της:


```python
sorted(a, key=sort_according_to_this)
```




    [['mitsos', 50, 4000], ['gianni', 30, 20000], ['anna', 60, 100000]]



Ένα άλλο παράδειγμα. Έστω η λίστα:


```python
a = ["heraklion", "patras", "thessaloniki", "athens"]
```

Η παρακάτω εντολή ταξινομεί τη συνάρτηση με βάσει το μήκος των strings:


```python
sorted(a, key=len)
```




    ['patras', 'athens', 'heraklion', 'thessaloniki']



Οι συναρτήσεις ```max``` και ```len``` επίσης υποστηρίζουν τη key=...:



```python
min(a,key=len) # H polh me to mikrotero onoma
```




    'patras'




```python
max(a,key=len) # H polh me to megalutero onoma
```




    'thessaloniki'




```python

```
